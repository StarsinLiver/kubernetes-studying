<쿠버네티스 교과서> 15~21장의 명령 모음입니다.
실습 편의를 위하여 만들었으며, 일부 설정 등은 책을 참고해야 하는 부분이 있습니다.
실습 시 복사하여 사용하세요.

15장

# 이번 장 예제 코드 디렉터리로 이동
cd ch15

# Hello World 애플리케이션을 배치
kubectl apply -f hello-kiamol/

# 배치된 서비스 객체가 내부 접근만 가능한지 확인
kubectl get svc hello-kiamol

# 애플리케이션에 포트포워드 설정을 추가
kubectl port-forward svc/hello-kiamol 8015:80

# http://localhost:8015를 확인
# 확인 후 Ctrl+C 또는 Cmd-C를 눌러 포트포워딩 종료

-----------------------------------------------------
# (역주) 실습 환경(k3s 기준)에 Traefik이 기본 포함된 경우 포트가 점유되서 오류가 발생하므로 다음 명령으로 Traefik을 수동 제거한 후 진행한다.
kubectl -n kube-system delete helmcharts.helm.cattle.io traefik

# Nginx 인그레스 컨트롤러의 디플로이먼트 및 서비스를 배치
kubectl apply -f ingress-nginx/

# 서비스가 준비되었는지 확인
kubectl get svc -n kiamol-ingress-nginx

# 프록시 URL을 확인
kubectl get svc ingress-nginx-controller -o jsonpath='http://{.status.loadBalancer.ingress[0].*}' -n kiamol-ingress-nginx

# URL에 접근(에러가 발생한다)
-----------------------------------------------------

# 라우팅 규칙이 담긴 인그레스 객체를 배치
kubectl apply -f hello-kiamol/ingress/localhost.yaml

# 인그레스 객체가 생성되었는지 확인
kubectl get ingress

# 앞서 예제의 웹 브라우저 창을 새로고침하라

-----------------------------------------------------
# hosts 파일에 도메인 정보 추가하기 - 윈도우
./add-to-hosts.ps1 hello.kiamol.local ingress-nginx

# 리눅스 또는 macOS
chmod +x add-to-hosts.sh && ./add-to-hosts.sh hello.kiamol.local ingress-nginx

# 인그레스 객체에 도메인 정보를 추가하기
kubectl apply -f hello-kiamol/ingress/hello.kiamol.local.yaml

# 인그레스 객체가 잘 수정되었는지 확인하기
kubectl get ingress

# http://hello.kiamol.local 페이지를 확인

-----------------------------------------------------
# hosts 파일에 도메인 추가(윈도우)
./add-to-hosts.ps1 vweb.kiamol.local ingress-nginx

# hosts 파일에 도메인 추가(리눅스/macOS)
./add-to-hosts.sh vweb.kiamol.local ingress-nginx

# 애플리케이션과 서비스, 인그레스를 배치한다
kubectl apply -f vweb/

# 인그레스의 도메인을 확인한다
kubectl get ingress

# http://vweb.kiamol.local과
# http://vweb.kiamol.local/v1 두 URL에 접근해 확인한다

-----------------------------------------------------
# hosts 파일에 도메인 추가(윈도우)
./add-to-hosts.ps1 todo.kiamol.local ingress-nginx

# hosts 파일에 도메인 추가(리눅스/macOS)
./add-to-hosts.sh todo.kiamol.local ingress-nginx

# 모든 경로를 허용하는 인그레스를 포함한 애플리케이션을 배치
kubectl apply -f todo-list/

# http://todo.kiamol.local/metrics에 접근을 시도한다

# 완전 일치 규칙이 적용된 인그레스 정의로 변경한다
kubectl apply -f todo-list/update/ingress-exact.yaml

# 애플리케이션은 그대로 동작하지만,
# /metrics, /config 등의 경로가 차단되는지 확인한다

-----------------------------------------------------
# 원주율 계산 애플리케이션의 도메인을 hosts에 추가한다(윈도우)
./add-to-hosts.ps1 pi.kiamol.local ingress-nginx

# 원주율 계산 애플리케이션의 도메인을 hosts에 추가한다(리눅스/macOS)
./add-to-hosts.sh pi.kiamol.local ingress-nginx

# 간단한 인그레스가 적용된 애플리케이션 정의를 배치
kubectl apply -f pi/

# http://pi.kiamol.local?dp=30000 로 애플리케이션에 접근한다
# 새로고침 후 원주율 계산에 걸리는 시간이 같은지 확인한다

# 캐싱을 추가한 인그레스 정의로 변경한다
kubectl apply -f pi/update/ingress-with-cache.yaml

# 조금 전과 같은 URL로 소수점 3만 자리까지 원주율을 계산한다
# 처음에는 몇 초 시간이 걸리지만, 새로고침은 빠르게 이뤄진다

-----------------------------------------------------
# 스케일링을 일으킨다. 컨트롤러는 파드 간에 로드밸런싱을 적용한다
kubectl scale deploy/todo-web --replicas 3

# 추가되는 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=todo-web

# http://todo.kiamol.local/new 페이지에 접근해
# 새 항목을 추가하려 하면 400 오류 페이지가 뜨며 실패한다

# 애플리케이션 로그에서 원인을 확인한다
kubectl logs -l app=todo-web --tail 1 --since 60s

# 인그레스를 변경해 스티키 세션을 적용한다
kubectl apply -f todo-list/update/ingress-sticky.yaml

# 페이지를 새로고침한 다음 다시 새 항목을 추가한다
# 이번에는 이상 없이 항목이 추가된다

-----------------------------------------------------
# wc 명령으로 파일의 줄 수를 센다
kubectl exec -n kiamol-ingress-nginx deploy/ingress-nginx-controller -- sh -c 'wc -l /etc/nginx/nginx.conf'

-----------------------------------------------------
# Traefik 디플로이먼트 및 서비스, 보안 리소스를 생성한다
kubectl apply -f ingress-traefik/

# 인그레스 컨트롤러에서 동작하는 Traefik UI의 URL을 확인한다 
kubectl get svc ingress-traefik-controller -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8080' -n kiamol-ingress-traefik

# Traefik의 관리자 UI에서 현재 적용 중인 라우팅 규칙을 확인한다

-----------------------------------------------------
# hosts 파일에 새로운 도메인 정보를 추가한다(윈도우)
./add-to-hosts.ps1 todo2.kiamol.local ingress-traefik

# hosts 파일에 새로운 도메인 정보를 추가한다(리눅스/macOS)
./add-to-hosts.sh todo2.kiamol.local ingress-traefik

# 새로운 도메인을 대상으로 하는 인그레스 규칙과
# 스티키 세션이 적용된 새로운 서비스를 배치한다
kubectl apply -f todo-list/update/ingress-traefik.yaml

# Traefik 관리자 UI를 통해 새로운 라우터가 추가됐는지 확인한다
# 그리고 http://todo2.kiamol.local:8015 로 애플리케이션에 접근한다

-----------------------------------------------------
# Traefik의 자체 인증 서명서를 사용하도록 인그레스를 변경한다
kubectl apply -f todo-list/update/ingress-traefik-certResolver.yaml

# https://todo2.kiamol.local:9443으로 접근하면
# 브라우저에서 경고 메시지가 나타난다

-----------------------------------------------------
# 파드를 실행한다 - 파드가 실행되면 인증서가 생성된다.
kubectl apply -f ./cert-generator.yaml

# 서비스계정에 임시로 cluster-admin 권한을 부여한다
kubectl apply -f ./cert-temp-rolebinding.yaml

# 파드에 접속한다
kubectl exec -it deploy/cert-generator -- sh

# 파드 안에 인증서가 생성됐는지 확인한다
ls

# 인증서 및 키 파일의 이름을 쿠버네티스에서 사용하는 이름으로 변경한다
mv server-cert.pem tls.crt
mv server-key.pem tls.key

# 인증서 파일을 담은 비밀값을 만들고 비밀값에 레이블을 추가한다
kubectl create secret tls kiamol-cert --key=tls.key --cert=tls.crt
kubectl label secret/kiamol-cert kiamol=ch15

# 파드에 접속된 세션을 종료한다
exit

# 임시로 부여한 권한을 삭제한다.
kubectl delete -f ./cert-temp-rolebinding.yaml

# 호스트 컴퓨터로 돌아와 비밀값이 배치됐는지 확인한다
kubectl get secret kiamol-cert --show-labels

-----------------------------------------------------
# 인그레스를 변경한다
kubectl apply -f todo-list/update/ingress-traefik-https.yaml

# 이번에도 경고 메시지가 발생하지만 
# KIAMOL 인증 기관을 신뢰할 수 없기 때문이다.

-----------------------------------------------------
# 인그레스 리소스를 변경한다
kubectl apply -f todo-list/update/ingress-https.yaml

# https://todo.kiamol.local 에 접근한다.
# 경고 메시지를 무시하고 웹사이트에 접근한다

# HTTP 요청이 HTTPS로 리다이렉트 되는지 확인한다
curl http://todo.kiamol.local

-----------------------------------------------------
kubectl delete ns,all,secret,ingress -l kiamol=ch15

16장
# 이번 장의 예제 코드 디렉터리로 이동하기
cd ch16

# APOD 애플리케이션을 배치하기
kubectl apply -f apod/

# 파드가 준비될 때까지 대기하기
kubectl wait --for=condition=ContainersReady pod -l app=apod-web

# localhost 8016번 포트를 통해
# 오늘의 천체 사진을 볼 수 있는지 확인한다
# (Rancher Desktop의 경우 앞에서 나오던 주소를 사용해야 한다)
# (예: http://172.24.115.0:8016)

# sleep 파드를 실행하기
kubectl apply -f sleep.yaml

# sleep 파드에서 APOD API를 사용할 수 있는지 확인하기
kubectl exec deploy/sleep -- curl -s http://apod-api/image

# 측정값 엔드포인트를 통해 APOD API의 로그를 확인하기
kubectl exec deploy/sleep -- sh -c 'curl -s http://apod-log/metrics | head -n 2'

-----------------------------------------------------

# 네트워크 폴리시 객체 배치
kubectl apply -f apod/update/networkpolicy-api.yaml

# 배치 결과를 확인
kubectl get networkpolicy

# 아직 sleep 파드에서 APOD API에 접근이 가능한지 확인
kubectl exec deploy/sleep -- curl -s http://apod-api/image

-----------------------------------------------------
# 쿠버네티스 컨텍스트의 목록을 확인
kubectl config get-contexts

# 기존 클러스터로 컨텍스트를 전환
kubectl config set-context <기존_클러스터명>

# 기존 클러스터에 접근이 가능한지 확인
kubectl get nodes

-----------------------------------------------------
# 애플리케이션을 배치
kubectl apply -f pi/

# 애플리케이션이 준비될 때까지 대기
kubectl wait --for=condition=ContainersReady pod -l app=pi-web

# 파드 컨테이너의 사용자명 확인
kubectl exec deploy/pi-web -- whoami

#(역주)현재는 curl 유틸리티가 제거되어 있기 때문에 아래 명령으로 curl을 강제로 설치
kubectl exec deploy/pi-web -- sh -c 'apk update && apk add curl'

# 그대로 쿠버네티스 API 서버에 접근을 시도
kubectl exec deploy/pi-web -- sh -c 'curl -k -s https://kubernetes.default | grep message'

# API 접근 토큰을 출력하기
kubectl exec deploy/pi-web -- cat /run/secrets/kubernetes.io/serviceaccount/token

-----------------------------------------------------
# 시큐리티컨텍스트 필드를 통해 
# 애플리케이션의 권한을 일반 사용자로 낮춘다
kubectl apply -f pi/update/deployment-podsecuritycontext.yaml

# 새로운 파드가 준비될 때까지 대기
kubectl wait --for=condition=ContainersReady pod -l app=pi-web

# 애플리케이션을 실행한 사용자를 확인
kubectl exec deploy/pi-web -- whoami

# 쿠버네티스 API 토큰에 접근 가능한지 확인
kubectl exec deploy/pi-web -- ls -l /run/secrets/kubernetes.io/serviceaccount/token

# 쿠버네티스 API 토큰을 출력
kubectl exec deploy/pi-web -- cat /run/secrets/kubernetes.io/serviceaccount/token

-----------------------------------------------------
# 예제 16.3의 보안 설정을 적용해 파드를 변경
kubectl apply -f pi/update/deployment-no-serviceaccount-token.yaml

# 컨테이너에 쿠버네티스 API 토큰이 마운트되지 않은 것을 확인
kubectl exec deploy/pi-web -- cat /run/secrets/kubernetes.io/serviceaccount/token

# 쿠버네티스 API 서버가 접근 가능한지 확인
# 파드에서 curl이 제거되어 설치해야 하나, 앞의 실습으로 
# 일반 사용자로 권한이 격하되어 강제 설치가 불가능하다. 
# 따라서 실습하지 말고 패스한다.
kubectl exec deploy/pi-web -- sh -c 'curl -k -s https://kubernetes.default | grep message'

# 애플리케이션 URL을 통해 동작 여부를 확인
kubectl get svc pi-web -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8031'

-----------------------------------------------------
# 인증서 생성을 위해 임시 권한 부여
kubectl apply -f ./cert-temp-rolebinding.yaml

# 인증서 생성을 맡은 파드를 실행
kubectl apply -f ./cert-generator.yaml

# 컨테이너가 준비 상태가 되면 인증서 생성이 끝난 것이다
kubectl wait --for=condition=ContainersReady pod -l app=cert-generator

# (임시로 부여한 권한을 회수)
kubectl delete -f ./cert-temp-rolebinding.yaml

# 파드는 생성한 인증서를 TLS 비밀값으로 배치한다
kubectl get secret -l kiamol=ch16

# TLS 비밀값을 사용해 웹훅 서버를 배치
kubectl apply -f admission-webhook/

# 인증서를 화면에 출력한다
kubectl exec -it deploy/cert-generator -- cat ca.base64

-----------------------------------------------------
# 보안 설정 객체를 설치
helm install validating-webhook admission-webhook/helm/validating-webhook/ --set caBundle=$(kubectl exec -it deploy/cert-generator -- cat ca.base64)

# 객체가 잘 설치되었는지 확인
kubectl get validatingwebhookconfiguration

# 보안 설정을 위배하는 애플리케이션을 배치
kubectl apply -f vweb/v1.yaml

# 웹훅 로그를 확인
kubectl logs -l app=admission-webhook --tail 3

# 애플리케이션에 포함된 레플리카셋의 상태를 확인
kubectl get rs -l app=vweb-v1

# 위 레플리카셋의 상세 정보를 확인
kubectl describe rs -l app=vweb-v1

-----------------------------------------------------
# 웹훅 설정을 배치
helm install mutating-webhook admission-webhook/helm/mutating-webhook/ --set caBundle=$(kubectl exec -it deploy/cert-generator -- cat ca.base64)

# 웹훅이 잘 배치되었는지 확인
kubectl get mutatingwebhookconfiguration

# 또 다른 애플리케이션을 배치
kubectl apply -f vweb/v2.yaml

# 웹훅 서버의 로그를 화면에 출력
kubectl logs -l app=admission-webhook --tail 5

# 레플리카셋의 상태를 확인
kubectl get rs -l app=vweb-v2

# 레플리카셋의 상세 정보를 확인
kubectl describe pod -l app=vweb-v2

-----------------------------------------------------
# 헬름으로 배치한 웹훅 설정을 제거
helm uninstall mutating-webhook
helm uninstall validating-webhook

# Node.js로 구현된 웹훅 서버를 제거
kubectl delete -f admission-webhook/

# OPA 게이트키퍼 배치
kubectl apply -f opa/

-----------------------------------------------------
# 제약 템플릿을 먼저 배치
kubectl apply -f opa/templates/requiredLabels-template.yaml

# 그리고 제약을 배치
kubectl apply -f opa/constraints/requiredLabels.yaml

# 이 폴리시에 위배되는 to-do 애플리케이션을 배치
kubectl apply -f todo-list/

# 애플리케이션 배치가 차단되었는지 확인
kubectl get all -l app=todo-web

-----------------------------------------------------
# to-do 애플리케이션을 업데이트
kubectl apply -f todo-list/update/web-with-kiamol-labels.yaml

# 레플리카셋의 상태를 확인
kubectl get rs -l app=todo-web

# 레플리카셋의 상세 정보를 확인
kubectl describe rs -l app=todo-web

# 다음 실습을 위해 to-do 애플리케이션 제거
kubectl delete -f todo-list/update/web-with-kiamol-labels.yaml

-----------------------------------------------------
# 운영 환경 베스트 프랙티스 제약 템플릿을 생성
kubectl apply -f opa/templates/production/

# 제약 템플릿을 사용한 제약을 생성
kubectl apply -f opa/constraints/production/

# 업데이트된 to-do 애플리케이션을 배치
kubectl apply -f todo-list/production/

# 파드 생성이 차단되었는지 확인
kubectl get rs -n kiamol-ch16 -l app=todo-web

# 상세 오류 내용을 확인
kubectl describe rs -n kiamol-ch16 -l app=todo-web

-----------------------------------------------------
# 모든 제약을 준수하도록 애플리케이션을 변경
kubectl apply -f todo-list/production/update

# 파드가 준비될 때까지 대기
kubectl wait --for=condition=ContainersReady pod -l app=todo-web -n kiamol-ch16

# 파드가 동작 중임을 확인
kubectl get pods -n kiamol-ch16 --show-labels

# 애플리케이션 URL을 확인하고 웹 브라우저를 통해 접근
kubectl get svc todo-web -n kiamol-ch16 -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8019'

-----------------------------------------------------
kubectl delete -f opa/constraints/ -f opa/templates/ -f opa/gatekeeper.yaml
kubectl delete all,ns,secret,networkpolicy -l kiamol=ch16
-----------------------------------------------------

17장
# 이번 장 예제 코드 디렉터리로 이동
cd ch17

# 파워셸에는 grep 명령이 없으므로
# 윈도우 사용자는 다음 명령으로 먼저 grep 명령을 추가한다
. .\grep.ps1

# 쿠버네티스 API 버전을 확인해 RBAC 기능이 사용 가능한지 확인한다
kubectl api-versions | grep rbac

# 클러스터롤 중에 관리자 역할을 확인한다
kubectl get clusterroles | grep admin

# 클러스터 관리자 권한의 정의를 확인한다
kubectl describe clusterrole cluster-admin

-----------------------------------------------------
# 인증서 생성 도구 실행
kubectl apply -f user-cert-generator.yaml

# 컨테이너가 시작될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod user-cert-generator

# 로그를 확인한다
kubectl logs user-cert-generator --tail 3

# 인증서 파일을 로컬 컴퓨터로 복사한다
kubectl cp user-cert-generator:/certs/user.key user.key
kubectl cp user-cert-generator:/certs/user.crt user.crt

-----------------------------------------------------

# 새로 만든 인증서를 인증수단으로 등록
kubectl config set-credentials reader --client-key=./user.key --client-certificate=./user.crt --embed-certs=true

# 등록된 인증서를 인증수단으로 하는 컨텍스트를 생성
kubectl config set-context reader --user=reader --cluster $(kubectl config view -o jsonpath='{.clusters[0].name}')

# 새로운 컨텍스트에서 파드 배치를 시도한다
# 클러스터에 인증 설정이 되어 있다면 배치가 실패할 것이다
kubectl apply -f sleep/ --context reader

# 새로운 신원을 사용해 권한을 확인한다
kubectl get pods --as reader@kiamol.net

-----------------------------------------------------
# 일반 사용자로 sleep 파드를 배치한다
kubectl apply -f sleep/

# 앞서 정의한 롤바인딩을 배치한다
kubectl apply -f role-bindings/reader-view-default.yaml

# 새로운 사용자가 기본 네임스페이스에서 파드의 
# 상세 정보를 확인할 수 있는지 확인한다
kubectl get pods --as reader@kiamol.net

# system 네임스페이스에서는 상세 정보에 
# 접근이 안되는지 확인하라
kubectl get pods -n kube-system --as reader@kiamol.net

# 새로운 사용자로 파드를 삭제하려 하면 실패한다
kubectl delete -f sleep/ --as reader@kiamol.net

-----------------------------------------------------
# 맥 버전 도커 데스크톱: 이 명령을 사용해 RBAC 관련 버그를 수정한다
kubectl patch clusterrolebinding docker-for-desktop-binding --type=json --patch $'[{"op":"replace", "path":"/subjects/0/name", "value":"system:serviceaccounts:kube-system"}]'

# 윈도우용 도커 데스크톱이면 다음 명령을 사용한다
kubectl patch clusterrolebinding docker-for-desktop-binding --type=json --patch '[{\"op\":\"replace\", \"path\":\"/subjects/0/name\", \"value\":\"system:serviceaccounts:kube-system\"}]'

# 새로운 네임스페이스를 생성한다
kubectl apply -f namespace.yaml

# 서비스 계정의 목록을 확인한다
kubectl get serviceaccounts -n kiamol-ch17

# 현재 사용하는 계정의 권한을 확인한다
kubectl auth can-i "*" "*"

# 새로 만든 서비스 계정의 권한을 확인한다
kubectl auth can-i "*" "*" --as system:serviceaccount:kiamol-ch17:default
kubectl auth can-i get pods -n kiamol-ch17 --as system:serviceaccount:kiamol-ch17:default

-----------------------------------------------------
# 인증서 생성기 파드에서 can-i 명령을 사용해 인증서 생성 권한을 확인
kubectl exec user-cert-generator -- kubectl auth can-i create csr --all-namespaces

# 신원을 지정해 기본 서비스 계정의 해당 권한을 확인
kubectl auth can-i create csr -A --as system:serviceaccount:default:user-cert-generator

# 새로 만든 서비스 계정에는 해당 권한이 없음
kubectl auth can-i create csr -A --as system:serviceaccount: kiamol-ch17:default

-----------------------------------------------------
# 애플리케이션 및 RBAC 롤을 배치한다
kubectl apply -f kube-explorer/

# 파드가 시작될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=kube-explorer

# 애플리케이션의 URL을 확인한다
kubectl get svc kube-explorer -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8019'

# 애플리케이션에 접근한 다음, 기본 네임스페이스의
# 파드 목록을 확인할 수 있는지, 파드를 삭제할 수 있는지 확인하라.
# 그 다음 URL 뒤에 ?ns=kube-system을 붙여보면 오류가 발생한다

-----------------------------------------------------
# 새로운 롤 및 롤바인딩을 배치한다
kubectl apply -f kube-explorer/update/rbac-with-kube-system.yaml

# 애플리케이션 URL 뒤에 /?ns=kube-system을 붙인 채로
# 새로고침하면, 파드의 목록을 볼 수 있다.
# 하지만 파드 삭제는 불가능하다.

-----------------------------------------------------
# 애플리케이션을 실행한 네임스페이스의 레이블을 확인한다
kubectl get ns kiamol-ch17 --show-labels

# to-do 애플리케이션을 배치한다
kubectl apply -f todo-list/

# 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=todo-web -n kiamol-ch17

# 초기화 컨테이너의 로그를 출력한다
kubectl logs -l app=todo-web -c configurator --tail 1 -n kiamol-ch17

# 애플리케이션 URL을 확인하고 URL에 접근한다
kubectl get svc todo-web -n kiamol-ch17 -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8020'

-----------------------------------------------------
# 두 사용자를 생성한다
kubectl apply -f user-groups/

# sre 그룹의 사용자가 파드 삭제 권한이 있는지 확인한다(없음)
kubectl exec sre-user -- kubectl auth can-i delete pods

# 인증서의 상세 정보를 화면에 출력한다
kubectl exec sre-user -- sh -c 'openssl x509 -text -noout -in /certs/user.crt | grep Subject:'

# test 그룹의 사용자가 파드 로그 열람 권한이 있는지 확인한다(없음)
kubectl exec test-user -- kubectl auth can-i get pod/logs

# 이 인증서의 상세 정보도 화면에 출력한다
kubectl exec test-user -- sh -c 'openssl x509 -text -noout -in /certs/user.crt | grep Subject:'

-----------------------------------------------------
# 롤 및 롤바인딩을 배치한다
kubectl apply -f user-groups/bindings/

# sre 그룹의 사용자는 기본 네임스페이스 파드를 삭제할 수 없다
kubectl exec sre-user -- kubectl auth can-i delete pods

# 반면 ch17 네임스페이스의 파드는 삭제할 수 있다
kubectl exec sre-user -- kubectl auth can-i delete pods -n kiamol-ch17

# test 그룹의 사용자는 파드의 목록을 확인할 수 없다
kubectl exec test-user -- kubectl get pods

# 하지만 존재를 알고 있는 파드의 로그는 확인할 수 있다
kubectl exec test-user -- kubectl logs test-user --tail 1

-----------------------------------------------------
# 두 그룹의 네임스페이스, 서비스 계정, 토큰을 생성한다
kubectl apply -f user-groups/service-accounts/

# 그룹에 바인딩을 적용한다
kubectl apply -f user-groups/service-accounts/role-bindings/

# sre 그룹 사용자의 클러스터 전체 열람 권한을 확인한다
kubectl get clusterrolebinding sre-sa-view-cluster -o custom-columns='ROLE:.roleRef.name,SUBJECT KIND:.subjects[0].kind,SUBJECTNAME:.subjects[0].name'

-----------------------------------------------------
# 명령행 환경에 base64 명령을 추가하기(윈도우 환경에서만 입력)
. .\base64.ps1

# 토큰이 담긴 비밀값에서 토큰을 추출해 파일에 저장한다
kubectl get secret sre2-sa-token -n kiamol-authn-sre -o jsonpath='{.data.token}' | base64 -d > sa-token

# 토큰 파일을 새로운 인증수단으로 kubectl에 등록한다
kubectl config set-credentials ch17-sre --token=$(cat sa-token)

# sre 그룹의 인증수단을 사용하는 컨텍스트 생성한다
kubectl config set-context ch17-sre --user=ch17-sre --cluster $(kubectl config view -o jsonpath='{.clusters[0].name}')

# sre 그룹의 계정으로 파드 삭제가 가능한지 확인한다
kubectl delete pods -n kiamol-ch17 -l app=todo-web --context ch17-sre

-----------------------------------------------------
# 액세스 토큰을 삭제한다
kubectl delete secret sre2-sa-token -n kiamol-authn-sre

# 토큰 삭제가 반영될 때까지 대기한다
sleep 30

# sre 그룹의 계정으로 파드에 접근을 시도한다
kubectl get pods --context ch17-sre

-----------------------------------------------------
# 크루가 설치된 파드를 실행한다
kubectl apply -f rbac-tools/

# 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=rbac-tools

# 크루 컨테이너에 접속한다
kubectl exec -it deploy/rbac-tools -- sh

# who-can 플러그인을 설치한다
kubectl krew install who-can

# todo-list 컨피그맵에 접근 권한이 있는 사용자를 확인한다
kubectl who-can get configmap todo-web-config

-----------------------------------------------------

# access-matrix 플러그인을 설치한다
kubectl krew install access-matrix

# 파드에 대한 접근 권한 매트릭스를 출력한다
kubectl access-matrix for pods -n default

# 컨피그맵 todo-web-config에 대한 접근 권한 매트릭스를 출력한다
kubectl access-matrix for configmap todo-web-config -n default

-----------------------------------------------------
# rbac-lookup 플러그인을 설치한다
kubectl krew install rbac-lookup

# sre 검색어로 RBAC 권한 주체를 검색한다
kubectl rbac-lookup sre

# test 검색어로 검색한다
kubectl rbac-lookup test

-----------------------------------------------------
kubectl delete all,ns,rolebinding,clusterrolebinding,role,clusterrole,serviceaccount -l kiamol=ch17

18장
# 버추얼박스(VirtualBox)나 Hyper-V(윈도우), 패러렐즈(Parallels)(macOS) 등이 설치되어 있어야 한다
# 베이그런트 설치하기
# https://www.vagrantup.com에 접속해 내려받거나
# 환경에 따라 다음 명령을 사용한다(재부팅해야 적용됨)
# (윈도우) choco install vagrant
# (macOS) brew cask install vagrant

# 베이그런트는 가상 머신 이미지를 "박스"라는 형식으로 
# 패키징하는데, 리눅스 박스를 내려받는다.
# 이때 제공자를 선택하라고 하는데,
# 사용 중인 가상 머신 런타임을 선택해야 한다
vagrant box add bento/ubuntu-20.04

# 클러스터에서 윈도우를 사용하려면 윈도우 박스도 내려받는다(4GB가 넘으므로 패스해도 된다)
vagrant box add kiamol/windows-2019

-----------------------------------------------------
# 이번 장의 소스 코드 디렉터리로 이동한다
cd ch18

# 베이그란트로 가상 머신을 하나 실행한다
# 가상 머신 런타임은 앞서 선택한 것을 사용하며,
# 도중에 네트워크 선택 및 가상 머신에 마운트할 
# 로컬 컴퓨터 디렉터리를 선택해야 한다
vagrant up kiamol-control

# 가상 머신에 접속한다
vagrant ssh kiamol-control

# 이 디렉터리가 ch18 디렉터리와 연결돼 있다
cd /vagrant/setup

# 설치 스크립트를 실행 가능으로 설정한 다음 실행한다
# 윈도우에서 linux-setup.sh 파일을 찾을 수 없다고 나온다면 
# 윈도우용 파일이 아니기 때문이므로 다음 명령을 실행한 후 진행한다
# sudo apt install dos2unix 
# dos2unix linux-setup.sh
sudo chmod +x linux-setup.sh && sudo ./linux-setup.sh

# 도커 설치가 잘 됐는지 확인한다
which docker

# 모든 쿠버네티스 도구가 잘 설치됐는지 확인한다
ls /usr/bin/kube*

-----------------------------------------------------
# 새로운 클러스터를 초기화한다
sudo kubeadm init --pod-network-cidr="10.244.0.0/16" --service-cidr="10.96.0.0/12" --apiserver-advertise-address=$(cat /tmp/ip.txt)

# kubectl 설정 파일이 위치할 디렉터리를 생성한다
mkdir ~/.kube

# admin 설정 파일을 복사한다
sudo cp /etc/kubernetes/admin.conf ~/.kube/config

# kubectl이 설정 파일을 읽을 수 있도록 파일 권한을 변경한다
sudo chmod +r ~/.kube/config

# 쿠버네티스 클러스터를 확인한다
kubectl get nodes

-----------------------------------------------------
# 플란넬을 배치한다
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

# DNS 파드가 시작될 때까지 대기한다
kubectl -n kube-system wait --for=condition=ContainersReady pod -l k8s-app=kube-dns 

# 노드의 상태를 확인한다
kubectl get nodes

# 컨트롤플레인 가상 머신에서 로그아웃한다
exit

-----------------------------------------------------
# 노드가 될 새로운 가상 머신을 생성한다
vagrant up kiamol-node

# 새로 만든 가상 머신에 접속한다
vagrant ssh kiamol-node

# 설치 스크립트를 실행한다
sudo /vagrant/setup/linux-setup.sh

-----------------------------------------------------
# 앞서 컨트롤플레인을 생성할 때 출력된 join 명령을 입력해야 한다.
# 컨트롤플레인의 IP 주소, 토큰, 인증기관 인증서 해시가 다르다.
# 대강 이렇게 생긴 명령어라는 것만 참고하라
sudo kubeadm join 172.21.125.229:6443 --token 3sqpc7.a19sx21toelnar5i --discovery-token-ca-cert-hash sha256:ed01ef0e33f7ecd56f1d39b5db0fbaa56811ac055f43adb37688a2a2d9cc86b9

# 만약 토큰이 만료됐다면, 컨트롤플레인 노드에서 다음 명령을 실행하라
kubeadm token create --print-join-command

-----------------------------------------------------
# 컨트롤플레인 노드에 접속한다
vagrant ssh kiamol-control

# 각 노드의 상태를 확인한다
kubectl get nodes

# 새로 추가한 노드의 모든 파드 목록을 확인한다
kubectl get pods --all-namespaces --field-selector spec.nodeName=kiamol-node

-----------------------------------------------------
# 평소와 같이 매니페스트를 배치한다
kubectl apply -f /vagrant/apod/

# 파드의 상세 정보를 확인한다
kubectl get pods -o wide

-----------------------------------------------------
# 모든 노드에서 master 테인트를 제거한다
kubectl taint nodes --all node-role.kubernetes.io/master-

# APOD API의 파드 수를 세 개로 늘린다
kubectl scale deploy apod-api --replicas=3

# 파드의 배치 상황을 확인한다
kubectl get pods -l app=apod-api -o wide

-----------------------------------------------------
# 설치 스크립트를 실행하며 저장해둔 IP 주소를 출력하라
cat /tmp/ip.txt

# 출력된 주소의 30000번 포트로 접근해 보아라
# 단, 가상 머신 런타임의 네트워크 스택 구조에 따라 외부에서
# 접근이 어려울 수도 있다.

-----------------------------------------------------
# (리눅스, 옵션) 윈도우 노드 시작 시 
# 오류가 발생한다면 다음 명령을 실행한다
sudo gem install winrm-fs winrm-elevated

# 윈도우 서버 2019 가상 머신을 생성한다
vagrant up kiamol-node-win

# 가상 머신에 접속한다 - 패스워드는 vagrant다
vagrant ssh kiamol-node-win

# 파워셸을 실행하고 파워셸로 넘어간다
powershell

# 설치 스크립트를 내려받는다
curl.exe -s -O windows-setup.ps1 https://raw.githubusercontent.com/sixeyed/kiamol/master/ch18/setup/windows-setup.ps1

# 이 스크립트를 실행하라 - 실행이 끝나면 가상 머신이 재부팅된다
./windows-setup.ps1
-----------------------------------------------------

# 컨트롤플레인에 접속한다
vagrant ssh kiamol-control

# 윈도우 노드용 프록시를 설치한다
kubectl apply -f /vagrant/setup/kube-proxy.yml

# 윈도우 노드용 네트워크 플러그인을 설치한다
kubectl apply -f /vagrant/setup/flannel-overlay.yml

# 데몬셋이 잘 생성됐는지 확인한다
kubectl get ds -n kube-system

-----------------------------------------------------
# 윈도우 노드에 접속한다
vagrant ssh kiamol-node-win

# 파워셸을 실행한다
powershell

# 두 번째 설치 스크립트를 내려받는다
curl.exe -s -o PrepareNode.ps1 https://raw.githubusercontent.com/sixeyed/kiamol/master/ch18/setup/PrepareNode.ps1

# 내려받은 설치 스크립트를 실행한다
.\PrepareNode.ps1

# 노드 추가 명령을 실행한다.
# 앞서 클러스터 생성 시 복사해 둔 명령을 사용해야 한다.
# 아래 명령은 명령의 대강의 모양을 알려주기 위한 것이다
kubeadm join 172.21.120.227:6443 --token 5wbq7j.bew48gsfy0maa2bo --discovery-token-ca-cert-hash sha256:2c520ea15a99bd68b74d04f40056996dff5b6ed1e76dfaeb0211c6db18ba0393

-----------------------------------------------------
# 컨트롤플레인에 접속한다
vagrant ssh kiamol-control

# 모든 노드가 준비될 때까지 대기한다
kubectl -n kube-system wait --for=condition=Ready node --all

# 하이브리드 애플리케이션을 배치한다
kubectl apply -f /vagrant/numbers

# 윈도우 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=numbers,component=api

# 파드가 모두 준비됐는지 확인한다
kubectl get pods -o wide -l app=numbers

# 아무 노드에나 30001번 포트로 접근해 애플리케이션을 사용한다

-----------------------------------------------------
# 컨트롤플레인에서 펫샵 애플리케이션을 배치
kubectl apply -f /vagrant/petshop/

# 모든 파드가 준비될 때까지 대기 - 5분 이상 걸릴 수 있다
kubectl wait --for=condition=ContainersReady pod -l app=petshop --timeout=5m
kubectl get pods -o wide -l app=petshop

# 어느 노드든 30002번 포트로 애플리케이션에 접근한다

-----------------------------------------------------
# 1. 가상 머신을 모두 중단한다
# 이 경우 가상 머신의 상태가 저장되므로
# 호스트의 디스크와 메모리를 계속 소모한다
vagrant suspend

# 2. 가상 머신을 모두 종료한다
# 나중에 가상 머신을 다시 실행할 수 있지만
# 가상 머신의 IP 주소가 변경될 수 있어 클러스터를 사용하지 못할 수 있다
vagrant halt

# 3. 가상 머신을 모두 삭제한다
# 사용이 모두 끝났다면 가상 머신을 삭제해 클러스터를 완전히 제거한다
vagrant destroy
-----------------------------------------------------


19장

# 이번 장의 예제 코드 디렉터리로 이동한다
cd ch19

# 각 노드에 적용된 테인트를 확인한다
kubectl get nodes -o=jsonpath='{range.items[*]}{.metadata.name} {.spec.taints[*].key}{end}'

# sleep 애플리케이션을 배치한다
kubectl apply -f sleep/sleep.yaml

# 모든 노드에 테인트를 하나 추가한다
kubectl taint nodes --all kiamol-disk=hdd:NoSchedule

# sleep 파드가 아직 실행 중인지 확인한다
kubectl get pods -l app=sleep
-----------------------------------------------------

# 톨러레이션이 없는 파드를 실행한다
kubectl apply -f sleep/sleep2.yaml

# 파드가 보류 상태인지 확인한다
kubectl get po -l app=sleep2

# 예제 19-1와 같은 톨러레이션을 추가해
# 파드의 정의를 변경한다
kubectl apply -f sleep/update/sleep2-with-tolerations.yaml
kubectl get po -l app=sleep2
-----------------------------------------------------

# 노드에 부여된 레이블을 확인한다
kubectl get nodes --show-labels

# 디플로이먼트 정의를 잘못된 노드셀렉터를 포함한 채로 변경한다
kubectl apply -f sleep/update/sleep2-with-nodeSelector.yaml

# 파드의 상태를 확인한다
kubectl get pods -l app=sleep2
-----------------------------------------------------

# 예제 19-3의 변경된 정의를 반영한다 
kubectl apply -f sleep/update/sleep2-with-nodeAffinity-required.yaml

# 새 파드가 제대로 실행됐는지 확인한다
kubectl get po -l app=sleep2
-----------------------------------------------------

# 편의를 위해 노드의 테인트를 제거한다
kubectl taint nodes --all kiamol-disk=hdd:NoSchedule-

# 무작위 숫자 애플리케이션을 배치한다
kubectl apply -f numbers/

# 두 파드가 같은 노드에서 실행 중인지 확인한다
kubectl get pods -l app=numbers -o wide
-----------------------------------------------------

# 안티어피니티가 추가된 API 파드의 정의를 반영한다
kubectl apply -f numbers/update/api.yaml

# API 파드의 상태를 확인한다
kubectl get pods -l app=numbers

# API 파드 및 웹 파드의 수를 증가시킨다
kubectl scale deploy/numbers-api --replicas 3
kubectl scale deploy/numbers-web --replicas 3

# API 파드 및 웹 파드의 상태를 확인한다
kubectl get pods -l app=numbers
-----------------------------------------------------

# metrics-server가 설치돼 있다면 kubectl top 명령에서
# 리소스 사용량을 확인할 수 있다
kubectl top nodes

# heapster와 관련된 오류가 발생한다면
# metrics-server가 설치되지 않은 것이다
kubectl apply -f metrics-server/

# metrics-server가 준비될때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l k8s-app=metrics-server -n kube-system

# 1분 정도면 준비가 끝난다
sleep 60

# metrics-server 파드의 로그를 출력한다
kubectl logs -n kube-system -l k8s-app=metrics-server --tail 2

# 노드의 리소스 사용량을 다시 확인한다
kubectl top nodes
-----------------------------------------------------

# 원주율 계산 애플리케이션을 배치한다
kubectl apply -f pi/

# 파드가 준비 상태가 될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=pi-web

# HPA의 상세 정보를 확인한다
kubectl get hpa pi-cpu
-----------------------------------------------------

# 부하 스크립트를 실행한다(윈도우용)
.\loadpi.ps1

# 부하 스크립트를 실행한다(리눅스/macOS용)
chmod +x ./loadpi.sh && ./loadpi.sh

# metrics-server 및 HPA가 작동할 때까지 대기한다
sleep 60

# 디플로이먼트가 스케일링됐는지 확인한다
kubectl get hpa pi-cpu

# 파드의 평균 CPU 사용량을 확인한다
kubectl top pods -l app=pi-web
-----------------------------------------------------

# HPA를 새로운 정의로 변경한다
kubectl apply -f pi/update/hpa-cpu-v2.yaml

# 부하 스크립트를 다시 실행한다(윈도우)
.\loadpi.ps1

# 부하 스크립트를 다시 실행한다(리눅스/macOS)
./loadpi.sh

# HPA가 파드를 증가시킬 때까지 대기한다
sleep 60

# 파드가 증가한 것을 확인한다
kubectl get hpa pi-cpu

# 부하가 사라진 후, HPA가 파드를 감소시킬 때까지 대기한다
sleep 60

# 레플리카 수가 하나인지 확인한다
kubectl get hpa pi-cpu

# 디플로이먼트의 상세 정보를 확인한다
kubectl get deploy pi-web
-----------------------------------------------------

# 예제 코드 디렉터리로 이동한다
cd ch01/vagrant/

# 실습에 사용할 가상 머신을 생성한다
vagrant up

# 가상 머신에 접속한다
vagrant ssh

# 가상 머신 안에서 이번 장의 예제 코드 디렉터리로 이동한다
cd /kiamol/ch19

# 사용자 정의 설정이 적용된 kind 클러스터를 생성한다
kind create cluster --name kiamol-ch19 --config ./kind/kiamol-ch19-config.yaml --image kindest/node:v1.18.8

# 클러스터가 준비될 때까지 대기한다
kubectl -n kube-system wait --for=condition=Ready node --all

# 가상 머신의 메모리 잔량을 확인한다
./kind/print-memory.sh
-----------------------------------------------------

# 쿠버네티스 API 접근을 위한 프록시를 실행한다
kubectl proxy

# 새 터미널 세션에서 가상 머신에 다시 접속한다
cd ch01/vagrant/
vagrant ssh

# kubelet 설정을 확인하는 HTTP Get 요청을 보낸다
curl -sSL "http://localhost:8001/api/v1/nodes/$(kubectl get node -o jsonpath={‘.items[0].metadata.name’})/proxy/configz"
-----------------------------------------------------

# stress 파드를 실행하면 약 1.2GB의 메모리를 점유한다(기존 터미널에서 실행)
kubectl apply -f stress/stress.yaml

# 모든 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=stress

# 노드의 메모리 현황을 확인한다
./kind/print-memory.sh

# stress 파드의 목록을 확인한다
kubectl get pods -l app=stress

# 배치했던 애플리케이션을 제거한다
kubectl delete -f stress/stress.yaml

-----------------------------------------------------
# 실습 클러스터를 정리한다
kubectl delete all,priorityclass,hpa -l kiamol=ch19

# metrics-server를 배치한 별도 실습 클러스터를 제거한다(19.3절)
kubectl delete -f metrics-server/

# 19.4절에서 만든 가상 머신을 제거한다
cd ch01/vagrant/
vagrant destroy
-----------------------------------------------------

20장

# 이번 장 예제 코드 디렉터리로 이동한다
cd ch20

# CRD를 배치한다
kubectl apply -f todo-custom/

# CRD의 상세 정보를 출력한다
kubectl get crd -l kiamol=ch20

# 사용자 정의 리소스 객체를 몇 개 생성한다
kubectl apply -f todo-custom/items/

# 사용자 정의 리소스의 목록을 확인한다
kubectl get todos

-----------------------------------------------------
# 출력되는 내용을 추가하도록 CRD 정의를 변경한다 
kubectl apply -f todo-custom/update/

# ToDo 리소스의 목록을 다시 한 번 확인한다
kubectl get todos

# ToDo 리소스 중 하나를 제거한다
kubectl delete todo ch21

# 남은 ToDo 리소스의 상세 정보를 확인한다
kubectl describe todo ch20

-----------------------------------------------------

# 클러스터에 배치된 CRD의 목록을 확인한다
kubectl get crds

# ToDo 리소스의 CRD를 제거한다
kubectl delete crd todos.ch20.kiamol.net

# ToDo 리소스 객체의 목록을 확인한다
kubectl get todos

-----------------------------------------------------
# CRD를 먼저 배치한다 
kubectl apply -f users/crd/

# 그다음 리소스를 배치한다
kubectl apply -f users/

# '사용자' 리소스의 목록을 출력한다
kubectl get users

-----------------------------------------------------
# 윈도우 환경에서는
# 비밀값을 복호화하기 위해 먼저 이 명령을 실행한다
. .\base64.ps1

# 사용자 정의 컨트롤러를 배치한다
kubectl apply -f user-controller/

# 컨트롤러가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=user-controller

# 컨트롤러의 로그를 확인한다
kubectl logs -l app=user-controller

# 비밀값에 들어있는 토큰을 출력한다
kubectl get secret tester3-token -n kiamol-ch20-authn-test -o jsonpath='{.data.token}' | base64 -d

-----------------------------------------------------
# sre 그룹의 사용자를 하나 더 추가한다
kubectl apply -f users/update/

# 컨트롤러의 최근 로그를 확인한다
kubectl logs -l app=user-controller --tail 4

# 새로 추가한 사용자의 토큰이 발급됐는지 확인한다
kubectl get secret sre4-token -n kiamol-ch20-authn-sre -o jsonpath='{.data.token}' | base64 -d

-----------------------------------------------------
# 인증용 네임스페이스의 목록을 확인한다
kubectl get ns -l kiamol=ch20

# test 그룹의 사용자를 삭제한다
kubectl delete user tester3

# 컨트롤러의 로그를 확인한다
kubectl logs -l app=user-controller --tail 3

# tester 그룹의 네임스페이스가 삭제됐는지 확인한다
kubectl get ns -l kiamol=ch20

-----------------------------------------------------
# 오퍼레이터에서 쓰이는 CRD 및 RBAC 규칙을 배치한다
kubectl apply -f nats/operator/00-prereqs.yaml

# 오퍼레이터를 배치한다
kubectl apply -f nats/operator/10-deployment.yaml

# 오퍼레이터가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l name=nats-operator

# NATS에서 사용하는 CRD의 목록을 확인한다
kubectl get crd

-----------------------------------------------------
# 예제 20-5의 메시지 큐 정의를 배치한다
kubectl apply -f todo-list/msgq/

# 메시지 큐의 목록을 확인한다
kubectl get nats

# 오퍼레이터가 생성한 파드의 목록을 확인한다
kubectl get pods -l app=nats

# 오퍼레이터가 생성한 서비스 목록을 확인한다
kubectl get svc -l app=nats

# 오퍼레이터가 생성한 비밀값 목록을 확인한다
kubectl get secrets -l app=nats

-----------------------------------------------------

20.4절부터 시작
# RBAC 규칙 및 오퍼레이터를 배치한다
kubectl apply -f web-ping/operator/

# 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=web-ping-operator

# 설치 컨테이너의 로그를 확인한다
kubectl logs -l app=web-ping-operator -c installer

# 새로 설치된 CRD의 목록을 확인한다
kubectl get crd -l operator --show-labels

# 오퍼레이터에 포함된 파드의 목록을 확인한다
kubectl get pods -l app=web-ping-operator
-----------------------------------------------------

# WebPinger 리소스를 배치한다
kubectl apply -f web-ping/pingers/webpinger-blog.yaml

# 오퍼레이터의 최근 로그를 출력한다
kubectl logs -l app=web-ping-operator -c pinger-controller --tail 4

# web-ping 애플리케이션 파드의 목록을 확인한다(시간이 좀 걸림)
kubectl get po -l app=web-ping --show-labels

# web-ping 애플리케이션의 로그를 확인한다
kubectl logs -l app=web-ping,target=blog.sixeyed.com -c web --tail 2

# 응답 로그가 JSON 파일로도 남겨지는지 확인한다
kubectl exec deploy/wp-blog-sixeyed-com -c web -- tail /logs/web-ping.log -n 2

-----------------------------------------------------
# 로그 파일의 줄 수를 출력한다
kubectl exec deploy/wp-blog-sixeyed-com -c web -- wc -l /logs/web-ping.log

# 로그 아카이빙 리소스를 생성한다
kubectl apply -f web-ping/pingers/archives/webpingerarchive-blog.yaml

# 오퍼레이터가 아카이빙에 필요한 잡 리소스를 생성하는지 확인한다(시간이 좀 걸림)
kubectl get jobs -l kiamol=ch20

# 아카이빙 리소스의 파드 로그를 확인한다
kubectl logs -l app=web-ping-archive,target=blog.sixeyed.com --tail 2

# web-ping 애플리케이션 로그 파일이 비워졌는지 확인한다
kubectl exec deploy/wp-blog-sixeyed-com -c web -- wc -l /logs/web-ping.log

-----------------------------------------------------
# web-ping 오퍼레이터의 CRD를 삭제한다(레이블로 지정)
kubectl delete crd -l operator=web-ping

# web-ping 컨트롤러의 최근 로그를 출력한다
kubectl logs -l app=web-ping-operator -c pinger-controller --tail 4

# 아카이빙 컨트롤러의 최근 로그를 출력한다
kubectl logs -l app=web-ping-operator -c archive-controller --tail 2

-----------------------------------------------------
kubectl delete all,crd,secret,clusterrolebinding,clusterrole,serviceaccount,ns -l kiamol=ch20

kubectl delete pvc -l app=mysql-operator

kubectl delete configmap mysql-operator-leader-election
-----------------------------------------------------

21장
# 이번 장 예제코드 디렉터리로 이동한다
cd ch21

# CRD와 사용자 정의 컨트롤러를 배치한다
kubectl apply -f kubeless/

# 컨트롤러가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l kubeless=controller -n kubeless

# CRD의 목록을 확인한다
kubectl get crd

-----------------------------------------------------
# Kubeless CLI가 설치된 파드를 실행한다
kubectl apply -f kubeless-cli.yaml

# 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod kubeless-cli

# 파드에 접속한다
kubectl exec -it kubeless-cli -- sh

# Kubeless의 설정 내용을 확인한다 
kubeless get-server-config

# 다음 실습까지 파드 접속을 유지한다

-----------------------------------------------------
# 파드 안에 있는 예제 코드 디렉터리로 이동한다
cd /kiamol/ch21

# 예제 21-1의 자바로 구현한 서버리스 펑션을 배치한다
kubeless function deploy hello-kiamol --runtime java11 --handler Kiamol.hello --from-file functions/hello-kiamol/hello-kiamol.java

# 서버리스 펑션의 목록을 확인한다
kubeless function ls

# 서버리스 펑션이 만든 파드와 컨피그맵의 목록을 확인한다
kubectl get pods -l function=hello-kiamol
kubectl get cm -l function=hello-kiamol

# 파드의 정보에서 빌드 단계를 확인한다
kubectl describe pod -l function=hello-kiamol | grep INFO | tail -n 5

-----------------------------------------------------
# 서버리스 펑션의 서비스를 확인한다
kubectl get svc -l function=hello-kiamol

# 클러스터 외부로부터 들어오는 HTTP 요청을
# 서버리스 펑션의 서비스에 전달할 프록시를 실행한다
kubectl proxy -p 8080 &

# 프록시를 통해 HTTP 요청으로 
curl http://localhost:8080/api/v1/namespaces/default/services/ hello-kiamol:http-function-port/proxy/

# Kubeless CLI를 통하면 더 간단하다
kubeless function call hello-kiamol

# 이제 파드에 접속한 터미널 세션을 종료한다
exit

-----------------------------------------------------
# 애플리케이션의 컴포넌트를 모두 배치한다
kubectl apply -f todo-list/config/ -f todo-list/db/ -f todo-list/msgq/ -f todo-list/web/ -f todo-list/save-handler/

# 애플리케이션 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=todo-list

# 애플리케이션의 URL을 확인한다
kubectl get svc todo-web -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8021'

# 애플리케이션에 접근해 정상 동작하는지 확인한다

-----------------------------------------------------
# Kubeless CLI 파드에 접속한다
kubectl exec -it kubeless-cli -- sh

# 이번 장 예제 코드 디렉터리로 이동한다
cd /kiamol/ch21

# 의존 모듈을 사용하는 서버리스 펑션을 배치한다
kubeless function deploy todo-api --runtime nodejs12 --handler 읻ㄱ --ㄹ개ㅡ-ㄹserver.handler --from-file functions/todo-api/server.js --dependencies functions/todo-api/package.json

# 서버리스 펑션의 상세 정보를 확인한다
kubeless function ls todo-api

# 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l function=todo-api

# 서버리스 펑션을 호출한다
kubeless function call todo-api --data 'Finish KIAMOL ch21'

# 서버리스 펑션의 로그를 확인한다
kubeless function logs todo-api | grep event

# 애플리케이션 메시지 핸들러의 로그를 확인한다
kubectl logs -l component=save-handler --tail 1

# CLI 파드의 터미널 세션을 종료한 뒤, 애플리케이션을 새로고침 한다
exit

-----------------------------------------------------
# Nginx 인그레스 컨트롤러를 배치한다
kubectl apply -f ingress-nginx/

# 애플리케이션과 API에 적용될 인그레스 규칙을 배치한다
kubectl apply -f todo-list/web/ingress/ -f functions/todo-api/ingress/

# 인그레스 규칙을 확인한다
kubectl get ingress

# hosts 파일에 도메인 정보를 추가한다(윈도우)
.\add-todo-to-hosts.ps1

# hosts 파일에 도메인 정보를 추가한다(리눅스/macOS)
chmod +x ./add-todo-to-hosts.sh && ./add-todo-to-hosts.sh

# API 펑션을 통해 할일 항목을 추가한다
curl --data 'Plan KIAMOL ch22' http://api.todo.kiamol.local/todos

# http://todo.kiamol.local/list에서 할일 목록을 확인한다

-----------------------------------------------------
# Kubeless CLI 파드에 접속한다
kubectl exec -it kubeless-cli -- sh

# 이번 장 예제 코드 디렉터리로 이동한다
cd /kiamol/ch21

# 펑션을 배치한다
kubeless function deploy todo-audit --runtime python3.7 --handler audit.handler --from-file functions/todo-audit/audit.py

# 펑션의 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l function=todo-audit

# 펑션의 상태를 확인한다
kubeless function ls todo-audit

# 새로 배치한 펑션을 호출한다
kubeless function call todo-audit --data '{"Item":{"Item":"FAKE ITEM!","DateAdded":"2020-07-31T08:37:41"}}'

# 펑션의 로그를 확인한다
kubeless function logs todo-audit | grep AUDIT

# Kubeless CLI 파드의 터미널 세션을 종료한다
exit

-----------------------------------------------------
# NATS 트리거를 배치한다
kubectl apply -f kubeless/nats-trigger/

# 트리거 컨트롤러가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l kubeless=nats-trigger-controller -n kubeless

# Kubeless CLI 파드에 접속한다
kubectl exec -it kubeless-cli -- sh

# 트리거를 생성한다
kubeless trigger nats create todo-audit --function-selector function=todo-audit --trigger-topic events.todo.newitem

# Kubeless CLI 세션을 종료한다
exit

# API 펑션을 호출한다
curl --data 'Promote DIAMOL serialization on YouTube' http://api.todo.kiamol.local/todos

# 메시지 검증 로그를 확인한다
kubectl logs -l function=todo-audit

-----------------------------------------------------
# Kubeless 리소스를 생성한다
kubectl apply -f functions/todo-mutating-handler/

# 스케줄 트리거의 목록을 확인한다
kubectl get cronjobtriggers

# 크론잡의 목록을 확인한다
kubectl get cronjobs

# 잡이 실행될 때까지 대기한다
sleep 90

# 잡 파드의 로그를 확인한다
kubectl logs -l job-name --tail 2

# to-do 애플리케이션을 새로고침한다

-----------------------------------------------------
# 펑션과 트리거를 제거하기 위해 사용자 정의 리소스를 삭제한다
kubectl delete cronjobtriggers,natstriggers,httptriggers,functions --all

# Serverless CLI 파드를 생성한다
kubectl apply -f serverless-cli.yaml

# 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod serverless-cli

# Serverless CLI가 설치됐는지 확인한다
kubectl exec serverless-cli -- serverless --version

-----------------------------------------------------
# Serverless CLI 파드에 접속한다
kubectl exec -it serverless-cli -- sh

# API 소스 코드가 있는 디렉터리로 이동한다 
cd /kiamol/ch21/serverless/todo-api

# 의존 모듈을 설치한다
npm install

# 펑션을 배치한다
serverless deploy

# Kubeless 펑션의 목록을 확인한다
kubectl get functions

# Kubeless 펑션의 파드가 생성됐는지 확인한다 
kubectl get pods -l function=todo-api

# HTTP 트리거의 목록을 확인한다
kubectl get httptriggers

-----------------------------------------------------
# 메시지 검증 펑션 디렉터리로 이동한다
cd /kiamol/ch21/serverless/todo-audit

# Serverless에 필요한 Node.js 의존 모듈을 설치한다
npm install

# 펑션을 배치한다
serverless deploy

# 펑션이 잘 배치됐는지 확인한다
kubectl get functions

# 트리거도 확인한다
kubectl get natstriggers

# Serverless CLI 터미널 세션을 종료한다
exit

-----------------------------------------------------
# 파워셸을 사용 중이라면 grep 명령을 추가한다
.\grep.ps1

# API 펑션을 호출한다
curl --data 'Sketch out volume III of the trilogy' http://api.todo.kiamol.local/todos

# 메시지 핸들러의 최근 로그를 확인한다
kubectl logs -l component=save-handler --tail 2

# 메시지 검증 펑션의 로그를 확인한다
kubectl logs -l function=todo-audit | grep AUDIT

-----------------------------------------------------
kubectl delete -f kubeless/

kubectl delete ns,all,secret,configmap,pvc,ingress -l kiamol=ch21
-----------------------------------------------------

