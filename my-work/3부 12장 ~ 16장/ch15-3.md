<!-- 인그레스 컨트롤러 비교하기 -->
# 인그레스 컨트롤러는 크게 두가지 유형으로 나뉜다.
# 하나는 리버스 프록시다.
# 오랫동안 쓰였으며, 네트워크 수준에서 동작하고 호스트 네임을 기준으로 콘텐츠를 가져온다.
# 다른 하나는 현대적 프록시다
# 플랫폼마다 달리 동작하며 다른 서비스(클라우드에서 제공하는 컨트롤러는 외부 로드밸런서를 활용할 수 있음)와 통합이 쉽다.

# 인그레스 컨트롤러는 클러스터 외부에서 클러스터 안 모든 애플리케이션에 접근하는 단일 통로가 된다.
# 따라서 이와 관련된 관심사를 모두 모아 놓기에도 좋은 지점이다.
# 모든 컨트롤러는 SSL 터미네이션을 지원한다.
# 프록시에서 보안 계층을 제공하므로 한곳에서 모든 애플리케이션에 HTTPS 적용을 할 수 있다.
# 또한 대부분의 컨트롤러는 웹 애플리케이션 방화벽을 지원하기 때문에 프록시 계층에서 SQL 인젝션과 같은 공격을 방어할 수 있다.
# 우리가 Nginx를 캐싱 프록시로 사용했듯이, 인그레스 레벨에서 컨트롤러를 사용한 캐싱도 지원하는 컨트롤러가 있다

<!-- ingress-with-cache.yaml : 캐시가 적용된 인그레스 컨트롤러 -->
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:                       # 인그레스 컨트롤러는 애너테이션에서 설정을 읽는다.
  name: pi                      # 여기에서는 프록시 캐싱이 적용되었다.
  labels:
    kiamol: ch15
  annotations:
    nginx.ingress.kubernetes.io/proxy-buffering: "on"   #  
    nginx.ingress.kubernetes.io/configuration-snippet: |
      proxy_cache static-cache;
      proxy_cache_valid 10m;
...

<!-- 실습 -->
# 인그레스가 사용된 원주율 계산 애플리케이션을 배치하라. 그리고 인그레스 객체를 변경하여 애플리케이션이 Nginx 캐시를 사용하도록 하라.

# 원주율 계산 애플리케이션의 도메인을 hosts에 추가한다(윈도우)
./add-to-hosts.ps1 pi.kiamol.local ingress-nginx

# 원주율 계산 애플리케이션의 도메인을 hosts에 추가한다(리눅스/macOS)
./add-to-hosts.sh pi.kiamol.local ingress-nginx

# 간단한 인그레스가 적용된 애플리케이션 정의를 배치
kubectl apply -f pi/

# http://pi.kiamol.local?dp=30000 로 애플리케이션에 접근한다
# 새로고침 후 원주율 계산에 걸리는 시간이 같은지 확인한다

# 캐싱을 추가한 인그레스 정의로 변경한다
kubectl apply -f pi/update/ingress-with-cache.yaml

# 조금 전과 같은 URL로 소수점 3만 자리까지 원주율을 계산한다
# 처음에는 몇 초 시간이 걸리지만, 새로고침은 빠르게 이뤄진다

# 인그레스 컨트롤러가 클러스터에서 매우 강력한 컴포넌트임을 알수있다
# 애플리케이션 변경이나 추가 컴포넌트 없이 인그레스 규칙을 변경해서 애플리케이션에 캐싱을 적용할 수도 있다.
# 애플리케이션의 HTTP 응답에 캐싱 헤더를 제대로 갖추어야한다는 조건이 달리지만 이것은 원래 잘된다.

# 응답 캐시 기능은 인그레스 규칙에서 정의된 것이 아니어서 응답 캐시 기능을 지원하지 않는 인그레스 컨트롤러도 있다.
# 모든 사용자 정의 설정은 애너테이션으로 적용된다.

# 인그레스 객체의 설정은 여기 포함된 모든 규칙에 적용되므로, 애플리케이션 일부에 다른 설정이 필요하다면 여러 개의 인그레스 규칙을 두면 된다.
# 이 to-do 애플리케이션 역시 스케일링을 제대로 하려면 인그레스 컨트롤러 도움이 필요하다.
# 서비스의 파드가 여러개라면 인그레스 컨트롤러는 로드밸런싱은 적용하는데, 이 애플리케이션에는 크로스 사이트 요청 위조가 적용되어 새 항목 추가 페이지를 렌더링했던 파드 외의 파드로 새 항목 생성 요청이 들어가면 애플리케이션이 정상 동작 하지 않는다.
# 이런 제한이 있는 애플리케이션이 많이 있기 때문에 프록시에서 스티키 세션(sticky session)을 적용해야 한다.

<!-- 스티키 세션 -->
# 스티키 세션은 이그레스 컨트롤러가 한 사용자 요청을 같은 컨테이너로만 전달하게 하는 메커니즘이다.
# 오래된 설계의 유상태 애플리케이션에서는 스티키 세션을 반드시 적용해야 하는 정의가 많다.
# 스티키 세션은 로드밸런싱 효과를 잠재적으로 반감시키기 때문에 피할 수 있다면 사용하지 않는 것이 좋다.

<!-- 실습2 -->
# 이제 to-do 애플리케이션을 문제없이 스케일링할 방법을 알았다. 스케일링을 일으켜 본 후 인그레스 규칙을 변경하여 문제가 해결되는 지 확인하라.

# 스케일링을 일으킨다. 컨트롤러는 파드 간에 로드밸런싱을 적용한다
kubectl scale deploy/todo-web --replicas 3

# 추가되는 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=todo-web

# http://todo.kiamol.local/new 페이지에 접근해
# 새 항목을 추가하려 하면 400 오류 페이지가 뜨며 실패한다

# 애플리케이션 로그에서 원인을 확인한다
kubectl logs -l app=todo-web --tail 1 --since 60s

# 인그레스를 변경해 스티키 세션을 적용한다
kubectl apply -f todo-list/update/ingress-sticky.yaml

# 페이지를 새로고침한 다음 다시 새 항목을 추가한다
# 이번에는 이상 없이 항목이 추가된다

# 스케이링으로 애플리케이션의 레플리카가 증가하면 인그레스 컨트롤러에서 이들 레플리카에 로드밸런싱을 적용한다. 그러면 크로스 사이트 요청 위조 공격 방지 대책(CSRF)이 문제를 일으킨다.
# 인그레스 변경 후 스티키 세션이 적용되면 /new 경로에는 로드밸런싱이 해제되어 한 사용자의 요청은 모두 같은 파드에 전달되므로 크로스 사이트 요청 위조 공격 방지가 문제를 일으키지 않는다.

# to-do 애플리케이션에 사용된 인그레스는 호스트 네임,경로, 애너테이션이 조합되어 인그레스 규칙과 그 적용 대상이 결정된다. 컨트롤러 내부적으로 이런 규칙과 기능을 프록시 설정으로 변환한다.
# 여기에서는 Nginx 설정 파일이 될 것이다.

<!-- 실습 3 -->
# Nginx 설정 파일은 인그레스 컨트롤러 파드 속에 있다. 파드 안에 있는 Nginx 설정 파일의 크기를 확인해 보아라

# wc 명령으로 파일의 줄 수를 센다
kubectl exec -n kiamol-ingress-nginx deploy/ingress-nginx-controller -- sh -c 'wc -l /etc/nginx/nginx.conf'

# Nginx 설정 파일의 줄 수가 1700줄이 넘는 것으로 나온다.
# 인그레스 컨트롤러가 이런 복잡성을 끌고 다니기는 하지만, 여전히 우리 애플리케이션에 꼭 필요한 부분으로 프록시 관련 문제를 어렵지 않게 해결할 수 있어야한다.
# 이 경우 플랫폼 인식 기능이 있고 설정 파일이 그리 복잡하지 않은 새로운 이그레스 컨트롤러 도입을 고려해야한다.

<!-- Traefik -->
# 그 예로 Traefik을 살펴보겠다.
# Trafik은 오픈 소스 프록시로 2015년 발표된 이후 점점 널리 사용되고 있다.
# Trafik은 컨테이너를 고려해서 만들어졌으며, 플랫폼 PI에서 라우팅 목록을 작성할 수 있다.
# 도커와 쿠버네티스를 기본으로 지원하며 별도의 설정 파일을 유지 보수할 필요 없다.

# 쿠버네티스는 한 클러스터 안에 여러 개의 인그레스 컨트롤러를 둘 수 있는데, 이들은 로드밸런서 서비스의 형태로 외부에 노출된다.
# 운영환경에서는 인그레스 컨트롤러마다 IP주소를 따로 가지며 DNS 설정에서 도메인 네임을 이 인그레스에 연결하면 된다.

<!-- Trafik : 이미지 -->
... 이건 좀 많은데 ㅋㅋㅋㅋㅋ

<!-- 실습 4 -->
# 먼저 인그레스 컨트롤러에 사용자 정의 포트를 배정한 Traefik을 배치하자

# Traefik 디플로이먼트 및 서비스, 보안 리소스를 생성한다
kubectl apply -f ingress-traefik/

# 인그레스 컨트롤러에서 동작하는 Traefik UI의 URL을 확인한다 
kubectl get svc ingress-traefik-controller -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8080' -n kiamol-ingress-traefik

# Traefik의 관리자 UI에서 현재 적용 중인 라우팅 규칙을 확인한다

# 이번 실습 예제에서 Traefik 관리자 UI를 볼 수 있다.
# UI를 보면 현재 프록시에 적용된 라우팅 규칙을 확인할 수 있으며, 트래픽 처리 성능 지표를 수집하고 확인할 수 있다.
# Nginx 설정 파일에 비하면 훨씬 직관적으로 다룰 수 있다.
# Traefik이 곤리하는 두 개의 라우터(router)가 있다.
# 대시보드를 좀 더 살펴보면 알 수 있듯이, 이 화면에서는 인그레스 라우팅 규칙을 볼 수 없다.
# 여기있는 것들은 Traefik 자체의 대시보드를 위한 내부 라우팅 규칙으로 Traefik이 아직 클러스터 안에 있는 기존 인그레스 규칙을 발견하지 못했기 때문이다.

# Traefik이 to-do 애플리케이션과 원주율 계산 애플리케이션의 라우팅 규칙을 인식하지 못했을까?
# 설정이 달랐다면 기존 라우팅 규칙이 Trafik에 인식되었겠지만, 다중 인그레스 컨트롤러가 우리가 원하는 대로 동작하지는 않았을 것이다.
# 인입되는 요청을 두고 서로 경쟁을 벌였을 것이기 때문이다.
# 서로 다른 프록시 기능을 사용하려고 두 개 이상의 인그레스 컨트롤러를 실행했다면 애플리케이션에서도 어떤 인그레스 컨트롤러를 사용할 지 결정해야 한다.
# 여기에 쓰이는 것이 인그레스 클래스(ingress class)이다.

<!-- 인그레스 클래스 -->
# 인그레스 클래스는 스토리지 클래스와 개념이 비슷하다.
# Traefik을 처음 배치하면 인그레스 클래스 한 가지가 있는 상태인데, 이 클래스를 요청한 인그레스 객체만 Traefik에서 처리된다.
# Traefik에는 응답 캐시가 없으므로 정적 리소스에 캐싱을 적용할 수 없다.
# 스티키 세션은 서비스 수준에서 설정되므로 새 항목 라우팅에 필요한 서비스를 추가해야한다.

# Traefik은 인그레스 리소스의 애너테이션을 통해 라우팅 규칙을 설정한다.
# 예제는 새 할일 항목 경로의 정의다. Traefik을 인그레스 클래스로 지정했고 애너테이션에 완전 일치 라우팅 규칙을 기술했다. 이렇게 한 이유는 Traefik에서 pathType 필드를 지원하지 않기 때문이다.

<!--! 현재 업데이트 되면서 이 부분은 좀 바뀐 부분이 있음 annotations 가 아닌 spec.IngressClassName으로 대체된것 같다.  -->

<!-- ingress-traefik.yaml : 인그레스 클래스 지정 및 Traefik 애너테이션 -->
...
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:                    # 인그레스 클래스를 traefik으로 지정하고
  name: todo2-new            # 완전 일치 경로 규칙을 기술하는 애너테이션
  labels:
    kiamol: ch15
  annotations:
    kubernetes.io/ingress.class: traefik
    traefik.ingress.kubernetes.io/router.pathmatcher: Path
spec:
  rules:
  - host: todo2.kiamol.local    # 새로운 도메인을 사용하므로
    http:                       # Nginx 인그레스 컨트롤러로도 애플리케이션을
      paths:                    # 계속 사용 가능하다
      - path: /new
        backend:
          service:
            name: todo-web-sticky     # Traefik에서 스티키 세션이 적용된 서비스
            port: 
              number: 80
...

# 다른 도메인이 설정된 인그레스 규칙을 한 벌 더 배치하자, 이러면 Nginx와 Traefik 두 컨트롤러를 통해 같은 to-do 애플리케이션 파드에 트래픽이 전달된다.

<!-- 실습 5 -->
# todo 애플리케이션을 Traefik 인그레스 컨트롤러로도 접근할 수 있도록 인그레스 라우팅 모델을 적용

# hosts 파일에 새로운 도메인 정보를 추가한다(윈도우)
./add-to-hosts.ps1 todo2.kiamol.local ingress-traefik

# hosts 파일에 새로운 도메인 정보를 추가한다(리눅스/macOS)
./add-to-hosts.sh todo2.kiamol.local ingress-traefik

# 새로운 도메인을 대상으로 하는 인그레스 규칙과
# 스티키 세션이 적용된 새로운 서비스를 배치한다
kubectl apply -f todo-list/update/ingress-traefik.yaml

# Traefik 관리자 UI를 통해 새로운 라우터가 추가됐는지 확인한다
# 그리고 http://todo2.kiamol.local:8015 로 애플리케이션에 접근한다

# Traefik은 쿠버네티스 API 서버에서 일어나느 이벤트를 주시하다 라우팅 리스트를 자동으로 갱신한다.
# 새로운 인그레스 객체가 배치되면 Traefik 대시보드의 라우터 목록에서 새로운 경로를 볼 수 있다.