<!-- 프로메테우스 클라이언트 라이브러리가 사용된 애플리케이션 모니터링 하기 -->
# 이번 애플리케이션의 컴포넌트는 자바,Go,Node.js 로 구현되었는데, 각기 해당 플랫폼의 프로메테우스 클라이언트 라이브러리로 애플리케이션과 런타임의 측정값을 외부로 제공하도록 만들어 졌다.
# 이 장 예제 코드에는 테스트 네임스페이스에 배치하도록 구성된 이 애플리케이션의 쿠버네티스 매니페스트 파일이 포함되어 있다. 테스트 네임스페이스에 배치되므로 이 애플리케이션 역시 프로메테우스의 스크래핑 대상이 된다.

<!-- 실습 -->
# APOD 애플리케이션을 테스트 네임스페이스에 배치하라 그리고 이 애플리케이션은 새 컴포넌트가 프로메테우스 스크래핑 대상에 추가되엇는지 확인하라

# # 애플리케이션을 배치한다
kubectl apply -f apod/

# 주 컴포넌트가 시작될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=apod-api -n kiamol-ch14-test

# 애플리케이션 URL을 확인한다
kubectl get svc apod-web -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:8014' -n kiamol-ch14-test

# 웹 브라우저에서 애플리케이션에 접근해 본 후
# 프로메테우스 스크래핑 대상 목록 페이지를 새로고침한다

# 애플리케이션은 의도대로 동작했고, 프로메테우스도 새 로 생성된 파드를 스크래핑 대상에 잘 추가햇다.
# 애플리케이션 배치 후 30초 이내에 모든 스크래핑 대상의 상태가 나타난것을 보아 모든 대상의 측정값이 제대로 수집되었다

<!--! 중요점 -->
# 이번 실습 예제에서 지적할 점이 두가지 있다
# 첫번째는 모든 파드의 정의에 컨테이너 포트가 지정되어 있다는 점이다.
# 이 설정을 따르면 애플리케이션 컨테이너가 80번 포트를 주시하며, 이 정보로 프로메테우스가 스크래핑 대상을 발견한다.
# 웹 UI를 외부에 노출하는 서비스는 8014번 포트를 주시하지만 프로메테우스는 이를 거치지 않고 80번 포트를 통해 파드로 직접 접근한다.

# 두번째는 API가 사용된 스크래핑 대상은 /metrics 페이지를 통해 측정값을 노출하지 않는다.
# 자바 클라이언트는 이와 다른 경로를 사용한다. 측정값을 제공하는 정확한 경로는 파드 정의의 애너테이션에 지정된다.

# 관습적으로 쓰이는 설정을 가정하고 스크래핑 대상을 찾는 전략은 반복적으로 동일한 설정을 기재할 필요가 없고, 실수의 여지가 적다는 장점이 있다
# 하지만 관습적 설정을 적용할 수 없는 애플리케이션이 있다.
# 프로메테우스에서 사용되는 리레이블링 파이프라인은 양자 간 절묘한 균형을 찾은 지점이라고 할 수 있다.
# 즉, 기본값을 그대로 사용할 수 있는 애플리케이션에는 이를 적용하고, 그럴수 없는 애플리케이션은 애너테이션을 이용하여 기본값을 오버라이드 해서 필요한 설정을 적용한다.

<!-- prometheus-config.yaml -->
...
        - source_labels:                  # test-pods 잡에서 사용될 리레이블링 설정
            - __meta_kubernetes_pod_annotationpresent_prometheus_io_path     
            - __meta_kubernetes_pod_annotation_prometheus_io_path
          regex: true;(.*)                # 파드 정의에 prometheus.io/path로 시작되는 애너테이션이 있다면 
          target_label:  __metrics_path__ # 이 애너테이션 값으로 스크래핑 경로를 지정한다.
...

# 일견 복잡해 보이지만 이해하면 그렇게 어렵지 않다.
# 여기 정의된 규칙의 의미는 파드 정의에 prometheus.io/path라는 애너테이션이 있다면 이 애너테이션 값을 스크래핑 경로로 사용하라는 것이다.
# 프로메테우스는 모든 규칙을 레이블을 통해 처리하므로 모든 파드의 애너테이션은 meta_kuberentes_pod_annotation_<애너테이션이름> 레이블로 변환된다.
# 여기에 이 레이블과 짝을 이루는 meta_kuberentes_pod_annotation_<애너테이션이름> 레이블을 사용하면 해당 애너테이션이 있는지 확인 할 수 있다.
# 기본값과 다른 스크래핑 경로를 설정해야 한다면 애너테이션만 추가하면 된다.

<!-- api.yaml -->
...
  template:                 # 디플로이먼트에 포함된 파드 정의
    metadata:
      labels:
        app: apod-api       # 프로메테우스의 잡 레이블
      annotations:  
        prometheus.io/path: "/actuator/prometheus"    # 스크래핑 경로
...

# 복잡한 설정은 프로메테우스 설정으로 다 몰아 주는 대신 애플리케이션 매니페스트에 직접적으로 스크래핑 경로를 지정할 수 있다.
# 기본 패턴을 그대로 사용하면서 조금씩 필요에 따라 수정해서 사용하는 한 리레이블링 규칙도 그렇게 어렵지 않다.
# 프로메테우스 전체 설정에는 이와 비슷한 방법으로 된 스크래핑을 위한 포트 설정 및 스크래핑 예외 설정도 포함 되어있다.

# 현재 UI도 질의를 던지고 반환된 응답을 확인하기에는 편리하지만, 현재 UI에서 한 화면에 일목요연하게 핵심 측정값을 모아 놓은 대시보드는 만들 수 없다.
# 이런 대시보드를 만들려면 또 다른 커네이터너 생태계의 오픈 소스 구성원인 그라파나(Grafana)를 사용해야 한다.
# 그라파나는 프로메테우스 개발 팀에서 프로메테우스와 함께 사용할것을 권장하는 도구다.

<!-- 실습 2 -->
# 그라파나, 그라파나가 프로메테우스에 접근할 수 있는 정보 및 APOD 애플리케이션의 대시보드 정의가 담긴 컨피그맵을 배치하라.

# 모니터링 네임스페이스에 그라파나를 배치한다
kubectl apply -f grafana/

# 그라파나가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=grafana -n kiamol-ch14-monitoring

# 대시보드를 보기 위한 URL 확인한다
kubectl get svc grafana -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:3000/d/kb5nhJAZk' -n kiamol-ch14-monitoring

# 확인한 URL에 접근해 사용자명/패스워드 kiamol로 로그인한다

# 간단한 대시보드이지만 시스템 상태를 파악하려면 측정값을 어떻게 활용했는지 알 수 있다.
# 대시보드의 각 그래프는 그라파나가 백그라운드에서 프로메테우스에 질의하여 얻어 온 정보를 나타낸다.
# 줄마다 각 컴포넌트의 런타임 관련 정보(CPU 및 메모리 사용량)와 애플리케이션 정보(HTTP 요청 수 및 캐시 사용량)가 표시된다.

# 이런 유형의 대시보드를 만들려면 여러 조직에 걸친 노력이 필요하다. 지원팀에서는 시스템 상태를 파악하는 데 필요한 정보 목록을 작성하고, 개발 팀과 운영 팀은 애플리케이션에서 해당 정보를 추출하고 이를 정리하여 대시보드를 구성하는 역할을 한다.
# 13장에서 배웠던 로그 처리 시스템과 마찬가지로 경량 오픈 소스 소프트웨어로 구성된 시스템이기 때문에 개발용 노트북에서도 운영 환경에서 동작하는 시스템과 동일한 모니터링 시스템을 사용할 수 있다.
# 이 점은 개발 환경과 테스트 환경에서 디버깅을 하는 데 많은 도움이 된다.

# 프로메테우스를 이용한 중앙화된 모니터링 스스템으로 이행하려면 어느 정도 개발 공수가 필요하다 
# 하지만 기본적인 측정값부터 시작해서 필요한 정보를 차근차근 늘려 가도록 개발 공수를 점진적으로 투입하면 된다.

<!-- 실습 3 -->
# 프로메테우스를 지원하는 to-do 애플리케이션을 배치하라. 이 애플리케이션에는 그라파나에서 사용할 수 있는 대시보드 정의가 포함되어 있다.

# 애플리케이션을 배치한다
kubectl apply -f todo-list/

# 애플리케이션이 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=todo-web -n kiamol-ch14-test

# 애플리케이션에 접근해 할일 항목을 추가한 다음
# 스크립트를 실행해 약간의 부하를 가한다(윈도우)
# (역주) 윈도우에서 보안 오류 발생 시 Set-ExecutionPolicy RemoteSigned 명령을
# 실행한다(y 선택)
.\loadgen.ps1

# 스크립트를 실행해 약간의 부하를 가한다(macOS/리눅스)
chmod +x ./loadgen.sh && ./loadgen.sh

# 대시보드를 보기 위한 URL 확인하기
kubectl get svc grafana -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:3000/d/Eh0VF3iGz' -n kiamol-ch14-monitoring

# 대시보드를 확인한다

# 이 대시보드가 그렇게 대단한 내용을 담기 있지는 않지만, 그래도 없는 것보다는 훨씬 낫다.
# 이정도의 대시보드만으로도 애플리케이션 컨테이너의 CPU 및 메모리 사용량과 할 일 아이템이 등록되는 단위 시간 건수, HTTP 요청이 처리되는 평균 을답 시간을 알 수 있다.

# 이 대시보드에 실린 측정값은 모두 to-do 애플리케이션 파드에서 수집된것이다.
# 웹 UI 말고도 PostgreSQL 데이터베이스와 웹 프록시까지 두 개의 컴포넌트가 더 있는데, 이들 컴포넌트는 프로메테우스가 끊임없이 스크래핑을 시도한다.
# 애플리케이션 모델링을 맡은 사라믕ㄴ 측정값 수집이 가능한 컴포넌트를 명확히 파악하고 그렇지 않은 컴포넌트를 스크래핑 대상에서 명시적으로 제외해야 한다.
# 간단한 애너테이션으로 부적절한 컴포넌트를 스크래핑 대상에서 제외한 예이다.

<!-- proxy.yaml : 프로메테우스 스크래핑 대상에서 제외하는 애너테이션이 포함된 파드 정의 -->
...
  template:
    metadata:
      labels:
        app: todo-proxy
      annotations:
        prometheus.io/scrape: "false"   # 프로메테우스 스크래핑 대상에서 제외
...

# 프로메테우스를 직접 지원할 필요가 없으므로 기본 측정값 수집 엔드포인트를 갖춘 컴포넌트는 그대로 스크래핑 대상에 포함시키면 된다.
# 프로메테우스도 나름의 생태계를 갖춘 제품이기 때문에 클라이언트 라이브러리 외에도 서드파티 애플리케이션에서 측정값을 추출하는 추출기가 있다.