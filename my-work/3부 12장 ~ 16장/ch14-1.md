<!-- 프로메테우스를 이용한 쿠버네티스 및 애플리케이션 모니터링 -->
# 모니터링은 로그와 둘도 없는 단짝이다. 모니터링으로 시스템에 발생한 이상 현상을 발견하고 로그를 열람하여 시스템에 어떤 일이 벌어졌는지 조사하낟,
# 로그 시스템과 마찬가지로 모니터링 역시 중앙화된 시스템에서 측정값을 수집하여 전체 애플리케이션 컴포넌트의 상태를 파악할 수 있다.
# 쿠버네티스 모니터링에는 역시 CNCF에서 관리하는 프로젝트인 프로메테우스(Prometheus)가 주로 쓰인다.

<!-- 프로메테우스 -->
# 프로메테우스는 클러스터의 측정값을 수집하고 저장하는 서버 애플리케이션이다.
# 프로메테우스를 지원하는 플랫폼은 여러가지가 있지만, 그중에서도 쿠버네티스는 특히 프로메테우스와 궁합이 좋은 플랫폼이다.
# 쿠버네티스 API 서버에 접근 권한이 있는 파드에서 프로메테우스를 실행하면 모든 모니터링 대상의 상태를 쿠버네티스 API를 통해 프로메테우스가 질의한다.
# 새로운 애플리케이션을 배치하더라도 설정을 변경할 필요 없다.
# 프로메테우스가 새로 배치된 애플리케이션을 발견하여 자동으로 측정값을 수집하기 시작하기 때문이다.

# 이 장에서는 사이드카 패턴을 활용하여 모든 애플리케이션이 프로메테우스에 자신의 상태 측정값을 제공하게 하는 방법을 알아보겠다.

<!-- 프로메테우스가 쿠버네티스 애플리케이션을 모니터링하는 과정 -->
# 프로메테우스가 수집하는 측정값은 아주 일반적인 것들이다.
# 모니터링 대상 컴포넌트에 HTTP 엔드포인트를 두고, 이 엔드 포인트가 해당 컴포넌트의 주요 상태 측정값을 제공하게 한다.
# 웹 서버라면 처리 요청 수를 들 수 있겠고, 쿠버네티스 노드라면 메모리 잔량 등이 있을 것이다.
# 프로메테우스는 측정값의 내용이나 의미는 상관하지 않으며 측정값을 수집해서 저장하는 역할만 한다.
# 프로메테우스에서 중요한 것은 측정값을 수집할 대상 컴포넌트 목록이다.

# 프로메테우스는 주기적으로 파드의 HTTP 엔드포인트에서 측정값을 수집한다.
# 이때 접근하는 주소는 파드의 IP로, 서비스를 경유하지 않는다.

# 이 장의 주요 내용은 프로메테우스를 쿠버네티스에 매끄럽게 통합해서 클러스터 확장이나 애플리케이션 추가 배치에도 동적으로 대응하는 모니터링 시스템을 갖추는 것이다.

# 먼저 프로메테우스를 배치해보자. 프로메테우스 서버는 서비스 디스커버리 및 측정값 수집, 저장을 담당하는 단일 컴포넌트다. 
# 또한 기본적인 웹 UI도 갖추고 있어 간단한 질의로 전체 시스템 상태를 확인할 수 있다.

<!-- 십습 -->
# 모니터링 전용 네임스페이스에 테스트 네임스페이스에 배치된 애플리케이션을 모니터링하도록 설정된 프로메테우스를 배치하라(단 테스트 네임스페이스는 아직 생성되지 않았다.)

# 이번 장 예제 코드 디렉터리로 이동한다
cd ch14

# 프로메테우스 디플로이먼트 및 컨피그맵을 배치한다
kubectl apply -f prometheus/

# 프로메테우스가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=prometheus -n kiamol-ch14-monitoring

# 웹 UI에 접근할 URL을 확인한다
kubectl get svc prometheus -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:9090' -n kiamol-ch14-monitoring

# 웹 UI에 접근해 /targets 페이지를 확인한다

# 프로메테우스에서는 측정값 수집을 스크랩 또는 스크래핑(scraping)이라고 한다.
# 프로메테우스 UI에 접근하면 test-pods 이름의 카테고리는 있지만 아직 스크랩 대상은 없다.

# (수집대상은 프로메테우스가 측정값을 스크랩해 오는 컴포넌트를 의미한다)
# (현재 설정은 테스트 네임스페이스에서 수집 대상을 찾도록 되어있는데 현재는 해당 네임스페이스가 없으므로 수집 대상도 없다.)

<!-- 프로메테우스가 쿠버네티스에서 수집 대상 찾는 방법 -->
# 프로메테우스가 쿠버네티스에서 수집 대상을 찾도록 하는 방법은 간단하다.
# 하지만 처음에는 용어가 헷갈릴 수도 있다.
# 프로메테우스에서 말하는 잡(Job)은 서로 연관된 수집 대상의 집합을 의미한다. 같은 애플리케이션을 구성하는 컴포넌트 모임이 흔히 볼 수 있는 잡의 예이다.
# 스크랩 설정은 도메인 네임의 고정된 목록처럼 간단할 수도 있고, 동적 서비스 디스커버리 형태가 될 수 있다.
# 이 설정에서는 서비스 디스커버리를 위해 쿠버네티스 API가 쓰였다.

<!-- prometheus-config.yaml -->
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: kiamol-ch14-monitoring
data:
  prometheus.yml: |-
    global:
      scrape_interval: 30s
     
    scrape_configs:                           # 컨피그맵 정의의 일부분이다.
      - job_name: 'test-pods'                 # 테스트 환경을 대상으로 한다. (그냥 잡 이름 정하기)
        kubernetes_sd_configs:                # 쿠버네티스 API를 통해 대상을 찾는다
        - role: pod                           # 파드를 대상으로 한다.
        relabel_configs:                      # 다음 필터링 규칙을 적용한다.
        - source_labels: 
            - __meta_kubernetes_namespace
          action: keep                        # 테스트 네임스페이스에 속한 
          regex: kiamol-ch14-test             # 파드만 대상으로 한다.
...


# relabel_configs 부분은 조금 설명이 필요할 것이다. 프로메테우스는 측정값을 레이블(label)과 함께 저장하는데, 이 레이블은 측정값의 출처와 그 외 정보를 담은 키-값 쌍이다.
# 원하는 측정값을 선택하거나 값을 취합하고 저장대상이 될 측정값을 선별하거나 가공하는데 이 레이블을 사용하는데, 이 작업을 리레이블(relableing)이라고 한다.
# 플루언트 비트의 로그 처리 파이프라인과 비슷한 개념이라고 볼 수 있다.
# 리레이블링 단계는 모니터링 대상이 될 모든 애플리케이션에 적용할 수 있을 만큼 일반적인 과정이어야 한다.
# 이 설정에서는 전체 파이프라인을 통틀어 다음 규칙이 적용된다.

1) kiamol-ch14-test 네임스페이스 속한 파드만 대상으로 한다.
2) 파드 이름을 프로메테우스 instance 레이블의 값으로 삼는다.
3) 파드 메타데이터 중 app 레이블의 값을 프로메테우스 job 레이블의 값으로 삼는다.
4) 파드 메타데이터의 애너테이션이 있다면 이 값을 이용하여 스크래핑 대상을 설정한다.

# 이 설정은 일반적으로 널리 쓰이는 방식이다. 애플리케이션이 이 규칙에 맞게 구성되었다면 자동으로 모니터링 대상에 포함된다.
# 이들 규칙에 부합하여 파드가 스크래핑 대상이 되면 프로메테우스는 이 파드의 /metric 경로에 HTTP GET 요청을 보내는 형태로 측정값을 수집한다.
# 이때 접근에 사용할 포트 정보가 필요하므로 파드 정의에도 컨테이너 포트를 명시적으로 지정해야 한다.
# 이런 이유가 아니더라도 컨테이너 포트를 명시적으로 지정해 두는 습관은 애플리케이션 구성을 문서화하기에 유리하다.

<!-- 실습 2 -->
# timecheck 애플리케이션을 테스트 네임스페이스에 배치하라. 이 애플리케이션 정의는 현재 설정된 프로메테우스의 스크래핑 대상을 결정하는 규치고가 일치하므로 프로메테우스가 새로 생성되는 파드를 발견하고 스크래핑 대상에 추가한다.

# timecheck 애플리케이션을 배치할 테스트 네임스페이스 생성
kubectl apply -f timecheck/

# 애플리케이션이 준비될 때까지 대기
kubectl wait --for=condition=ContainersReady pod -l app=timecheck -n kiamol-ch14-test

# 프로메테우스 UI를 새로 고침한 후
# timecheck 파드가 있는지 확인한다. 그 다음 /graph 페이지로 이동해
# 드롭다운 리스트에서 timecheck_total을 선택하고 Execute를 클릭하라

# 웹 브라우저 화면을 보면 프로메테우스가 timecheck 파드를 감지했고, 이 파드가 리레이블 단계의 모든 규칙과 일치하므로 스크래핑 대상에 포함된다.
# timecheck 애플리케이션에는 엔드포인트 /metric 이 있고 이 엔드포인트에서 timecheck 로그가 기록된 횟수를 반환한다.

<!--! 프로메테우스 사용시 중요점 -->
# 여기에서 중요한 것이 두가지 있다.
# 첫번째는 애플리케이션이 스스로 측정값을 제공할 수 있어야 한다.
# 프로메테우스는 측정값을 수집하는 역할만 하기 때문이다.
# 그리고 측정값 역시 애플리케이션 중 한 벌의 상태만 나타낼 수 있기 때문이기도 하다.
# timecheck 애플리케이션은 웹 애플리케이션이 아닌 백그라운드 프로세스다. 따라서 애플리케이션으로 트래픽을 유도해 줄 서비스가 없다.
# 프로메테우스는 쿠버네티스 API를 통해 파드의 IP주소를 알아낸다. 그리고 파드에 직접적으로 HTTP 요청을 보낸다.
# 서비스 대상으로도 요청을 보낼 수 있게 프로메테우스를 설정할 수는 있지만 여러 파드에 요청을 분배하는 로드밸런서 상태는 각 파드의 상태에 비하면 크게 의미가 없다.

# 이렇게 수집한 측정값으로 애플리케이션의 전체적인 상태를 일목요연하게 보여주는 대시보드를 만들 수 있다.
# 또는 모든 파드의 상태를 통합한 단일값을 계싼하여 보여주고, 상세한 상태를 세부적으로 내려 가며 보여 줄 수도 있다.
# 이런 방법으로 제대로 된 성능을 내지 못하는 특정 인스턴스를 식별하고 조치하면 헬스체크 결과에 조치가 반영된다.

<!-- 실습 2 -->
# timecheck 애플리케이션 레플리카를 한개 늘려보자. 새로운 파드 역시 프로메테우스의 스크래핑 대상 규칙에 부합하므로 스크래핑 대상에 포함된다.

# 디플로이먼트에 파드를 하나 추가한다
kubectl scale deploy/timecheck --replicas 2 -n kiamol-ch14-test

# 새로운 파드가 준비될 때까지 대기한다
kubectl wait --for=condition=ContainersReady pod -l app=timecheck -n kiamol-ch14-test

# 프로메테우스로 돌아가 스크래핑 대상 목록과 그래프 화면을 확인한 다음
# timecheck_total과 dotnet_total_memory_bytes 측정값을
# 반환하는 질의를 실행하라

# 프로메테우스의 스크래핑 대상 목록에 새로운 파드가 추가된다. 또한 동일한 측정값이 파드마다 레이블만 달리 부여되어 수집되는 것을 볼 수 있다.
# timecheck_total 측정값을 질의해보면, 파드마다 하나씩 두 개의 결과가 반환된다.
# 두 파드 중 한쪽이 훨씬 더 여러번 동작한 것을 알 수 있다.

# timecheck_counter는 애플리케이션 코드에서 명시적으로 수집된 값이다.
# 대부분의 프로그래밍 언어에는 프로메테우스 클라이언트 라이브러리가 있어 이를 그대로 사용하여 애플리케이션을 빌드하면 된다.
# 이 라이브러리를 사용하면 timecheck_counter같은 애플리케이션 특유의 측정값을 수집할 수 있다.
# 이외에도 애프릴케이션 런타임에 대한 일반적인 정보도 함께 수집한다.
# 이 애플리케이션은 닷넷 애플리케이션인데, 다음 적에서는 각 컴포넌트마다 프로메테우스에 측정값을 제공하는 분산 애플리케이션을 배치해 보고, 런타임의 성능 지표나 애플리케이션 상태를 보여주는 애플리케이션 대시보드가 얼마나 유용한지 체험해 보자.

