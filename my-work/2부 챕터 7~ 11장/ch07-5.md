<!-- 파드 환경 이해하기 -->
# 파드는 하나 이상의 컨테이너를 감싸는 경계이고, 컨테이너는 하나 이상의 프로세스를 감싸는 경계이다.
# 파드는 오버헤드 없이 가상화 계층을 추가하므로 유연하고 효율성이 뛰어남
# 다만 이런 유연성의 대가는 언제나 그렇듯이 복잡도의 상승이다.
# 따라서 멀티컨테이너 파드를 사용할 때는 이런 미묘한 차이에 주의해야 한다.

# 가장 중요한것은 파드는 컴퓨팅의 기본 단위라는 점이다. (여러 개의 컨테이너가 들어 있을 수 있더라도)
# 파드는 안의 모든 컨테이너 준비가 끝나야 자신도 준비 상태가 되고 서비스는 파드가 준비 상태가 되어야 트래픽을 전달한다.
# 사이드카 컨테이너나 초기화 컨테이너는 애플리케이션에 일종의 안전 모드를 추가하는 것과 같다.

<!-- 실습 -->
# 애플리케이션 업데이트
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl apply -f .\numbers\update\web-v2-broken-init-container.yaml
deployment.apps/numbers-web configured

# 새로 생성되는 파드를 확인
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl get po -l app=numbers-web,version=v2
NAME                          READY   STATUS                  RESTARTS     AGE
numbers-web-b8844dd94-8mtbx   0/2     Init:CrashLoopBackOff   1 (6s ago)   11s

# 새로 생성된 초기화 컨테이너의 로그 확인
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl logs -l app=numbers-web,version=v2 -c init-version
sh: can't create /config-out/version.txt: Read-only file system

# 디플로이먼트의 상태를 확인
# 디플로이먼트의 상태가 오해를 일으키기 쉽다.
# 디플로이먼트가 레플리카셋에 정상적으로 상태 보고를 하고있으므로 사용가능으로 나온다.
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl get deploy numbers-web
NAME          READY   UP-TO-DATE   AVAILABLE   AGE
numbers-web   1/1     1            1           30m

# 레플리카셋의 상태를 확인
# 하지만 실제 상태는 그렇지 않다.
# 새 레플리카셋이 (준비된 파드가 없어) 준비 상태가 되지 않았으므로 기존 레플리카셋이 아직 동작 중이다.
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl get rs -l app=numbers-web
NAME                     DESIRED   CURRENT   READY   AGE
numbers-web-6bfc8d9887   1         1         1       16m  // 기존
numbers-web-76447f6964   0         0         0       31m
numbers-web-b8844dd94    1         1         0       62s  // 생성된 레플리카셋

# 여기서 알 수 있듯이 초기화 컨테이너가 실패하면 애플리케이션이 업데이트 되지 않는 점이다.
# 새로 생성된 파드는 Running 상태로 진입하지 못해 서비스에서 트래픽을 전달받지 못한다.
# 디플로이먼트 역시 새 레플리카셋의 레플리카가 정해진 개수에 도달하지 못하기 때문에 기존 레플리카셋의 레플리카 수를 줄일 수 없다.
# 하지만 디플로이먼트의 상세 정보로는 업데이트가 반영된 것 처럼 보인다.

<!-- 재시작 조건 -->
# 다음과 같은 재시작 조건을 기억해두자
1) 초기화 컨테이너를 가진 파드가 대체될 때 새 파드는 초기화 컨테이너를 모두 실행한다. 따라서 초기화 로직을 반복적으로 실행할 수 있는 것이여야 한다.
2) 초기화 컨테이너의 이미지를 변경하면 파드 자체를 재시작한다. 초기화 컨테이너는 다시 한번 실행되며, 애플리케이션 컨테이너도 모두 교체된다.
3) 파드 정의에서 애플리케이션 컨테이너의 이미지를 변경하면 애플리케이션 컨테이너가 대체 된다. 초기화 컨테이너는 재시작하지 않는다.
4) 애플리케이션 컨테이너가 종료되면 파드가 애플리케이션 컨테이너를 재생성한다. 대체 컨테이너가 준비될 때까지 파드는 완전한 동작 상태가 아니게 되며, 서비스에서 트래픽을 전달 받지 못한다.

# 파드는 단일한 컴퓨팅 환경이다. 하지만 이 환경을 구성하는 부품이 여러 개일 때는 각각의 실패 시나리오를 검토하고 애플리케이션이 의도대로 동작하는지 확인해야한다.

# 아직 다루지 않은 파드 내 환경의 마지막 부분이 있다. 바로 컴퓨팅 계층이다.
# 파드 속 컨테이너는 네트워크 주소와 파일 시스템의 일부를 공유할 수 있다.
# 하지만 컨테이너 경계를 넘어 서로의 프로세스에는 접근할 수 없다.

# 파드 정의에 shareProcessNamespace:true 설정을 추가하면 이런 접근이 가능하다. 파드의 모든 컨테이너가 컴퓨팅 공간을 공유하며 서로의 프로세스를 볼 수 있게된다.

<!-- Todo : sleep-with-server-shared -->
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sleep
  labels:
    kiamol: ch07
spec:
  selector:
    matchLabels:
      app: sleep
  template:
    metadata:
      labels:
        app: sleep
        version: shared
    spec:
      shareProcessNamespace: true       # 컨테이너가 컴퓨팅 공간을 공유하도록 업데이트
      containers:
        - name: sleep
          image: kiamol/ch03-sleep        
        - name: server
          image: kiamol/ch03-sleep  
          command: ['sh', '-c', "while true; do echo -e 'HTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 7\n\nkiamol' | nc -l -p 8080; done"]
          ports:
            - containerPort: 8080
              name: http


<!-- 실습 2 -->
# 컨테이너가 컴퓨팅 공간을 공유하도록 sleep 파드를 업데이트하고, 다른 컨테이너의 포로세스에 접근이 가능한지 확인하라.

# 현재 컨테이너의 프로세스를 확인
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl exec deploy/sleep -c sleep -- ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh -c trap : TERM INT; (while true; do sleep 1000; done) & wait
    7 root      0:00 /bin/sh -c trap : TERM INT; (while true; do sleep 1000; done) & wait
   28 root      0:00 sleep 1000
   29 root      0:00 ps

# 파드를 업데이트
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl apply -f .\sleep\sleep-with-server-shared.yaml
deployment.apps/sleep configured

# 새 컨테이너가 준비될 때까지 대기
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl wait --for=condition=Ready pod -l app=sleep,version=shared
pod/sleep-665cb7855f-mm526 condition met

# 프로세스를 다시한번 확인
# 이제 sleep 컨테이너가 server 컨테이너에서 HTTP 서버 역할을 하는 nc 프로세스를 볼 수 있다.
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl exec deploy/sleep -c sleep -- ps
PID   USER     TIME  COMMAND
    1 65535     0:00 /pause
    7 root      0:00 /bin/sh -c trap : TERM INT; (while true; do sleep 1000; done) & wait
   12 root      0:00 /bin/sh -c trap : TERM INT; (while true; do sleep 1000; done) & wait
   13 root      0:00 sleep 1000
   14 root      0:00 sh -c while true; do echo -e 'HTTP/1.1 200 OK Content-Type: text/plain Content-Length: 7  kiamol' | nc -l -p 8080; done
   21 root      0:00 nc -l -p 8080
   22 root      0:00 ps

<!-- 7장 끝 -->
# 모든 리소스 제거
kubectl delete all -l kiamol=ch07