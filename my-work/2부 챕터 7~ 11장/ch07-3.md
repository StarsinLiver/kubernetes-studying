<!-- 어댑터 컨테이너를 이용한 일관성 있는 애플리케이션 관리 -->
# 모든 애플리케이션이 모든 조건을 숙지하고 이주해 오는 것도 아니고, 플랫폼이 외부에서 조건을 적용시킬 수 없을 때도 있다.
# 애플리케이션 컨테이너와 함께 동작하는 사이드카 컨테이너가 이런 상황에 도움이 될 수 있다.
# 애플리케이션과 컨테이너 플랫폼 사이를 중재하는 어댑터(adapter)역할을 맡기는 것이다. 로그는 그 중에서도 대표적인 예이다

# 모든 애플리캐이션은 어떤 혀앹로든 로그를 남기며, 또 그래야만 한다.
# 로그가 없다면 애플리케이션을 제대로 관리할 수 없기 때문이다.

# Node.js 나 닷넷 코어같은 현대적인 애플리케이션 플랫폼에서는 표준 출력 스트림에 로그를 출력한다.
# 도커와 쿠버네티스는 이 표준 출력으로 컨테이너의 로그를 수집한다.

# 하지만 이전 애플리케이션은 표준 출력 대신 파일에 직접 로그를 남기거나 컨테이너 로그가 수집될 수 없는 채널을 이용해서 로그를 남겼다.
# 이래서는 우리가 파드의 로그를 볼 수 없다.

<!-- Todo : timecheck-with-logging.yaml -->
apiVersion: apps/v1
kind: Deployment
metadata:
  name: timecheck
  labels:
    kiamol: ch07
spec:
  selector:
    matchLabels:
      app: timecheck
  template:
    metadata:
      labels:
        app: timecheck
        version: v3
    spec:
      initContainers:
        - name: init-config
          image: kiamol/ch03-sleep
          command: ['sh', '-c', 'cp /config-in/appsettings.json /config-out/appsettings.json']          
          volumeMounts:
            - name: config-map
              mountPath: /config-in
            - name: config-dir
              mountPath: /config-out
      containers:
        - name: timecheck
          image: kiamol/ch07-timecheck
          volumeMounts:
            - name: config-dir        
              mountPath: /config      
              readOnly: true
            - name: logs-dir          # 이 애플리케이션은 공디렉터리 볼륨의
              mountPath: /logs        # 파일에 로그를 기록한다.
        - name: logger
          image: kiamol/ch03-sleep    # tail -f 명령어 : 사이드카 컨테이너는 로그 파일을 주시한다.
          command: ['sh', '-c', 'tail -f /logs-ro/timecheck.log'] 
          volumeMounts:
            - name: logs-dir          
              mountPath: /logs-ro     # 애플리케이션과 같은 볼륨을 마운트
              readOnly: true
      volumes:
        - name: config-map
          configMap:
            name: timecheck-config
        - name: config-dir
          emptyDir: {}
        - name: logs-dir
          emptyDir: {}

<!-- 실습 -->
# 사이드카 컨테이너가 하는 일은 로그가 출력되는 볼륨(공디렉터리 볼륨)을 마운트하고 로그 파일의 내용을 tail 명령으로 표준 출력 스트림에 출력하는 것이 전부다.
# tail 명령의 -f 옵션은 파일을 주시하다 파일에 추가되는 내용을 그대로 출력하라는 의미다.
# 이런 방식으로 애플리케이션 로그 구현과 쿠버네티스의 로그 수집 방식을 연결하는 중재자 역할을 한다.

# 사이드카 컨테이너 추가
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl apply -f .\timecheck\timecheck-with-logging.yaml
deployment.apps/timecheck configured

# 컨테이너가 준비될 때까지 대기
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl wait --for=condition=Ready pod -l app=timecheck,version=v3
pod/timecheck-bb66db7b6-srjmk condition met

# 파드의 상태 확인
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl get pods -l app=timecheck
NAME                        READY   STATUS    RESTARTS   AGE
timecheck-bb66db7b6-srjmk   2/2     Running   0          111s

# 파드 속 컨테이너의 상태 확인
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl get pod -l app=timecheck -o jsonpath='{.items[0].status.containerStatuses[*].name}'
logger timecheck

# 파드의 로그를 확인할 수 있다.
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl logs -l app=timecheck -c logger
2024-01-15 05:06:44.532 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:06.44
2024-01-15 05:06:51.531 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:06.51
2024-01-15 05:06:58.530 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:06.58
2024-01-15 05:07:05.533 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:07.05
2024-01-15 05:07:12.532 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:07.12
2024-01-15 05:07:19.531 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:07.19
2024-01-15 05:07:26.529 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:07.26
2024-01-15 05:07:33.529 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:07.33
2024-01-15 05:07:40.529 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:07.40
2024-01-15 05:07:47.529 +00:00 [INF] Environment: TEST; version: 1.1; time check: 05:07.47

<!-- Todo : timecheck-good-citizen.yaml -->
apiVersion: v1
kind: Service
metadata:
  name: timecheck
  labels:
    kiamol: ch07              # 서비스 레이블 셀렉터 == 디플로이먼트 레이블 셀렉터
spec:
  ports:
    - port: 8080
      targetPort: 8080
      name: healthz
    - port: 8081
      targetPort: 8081
      name: metrics
  selector:
    app: timecheck            # 서비스 관리 레이블 셀렉터 == 파드 레이블 셀렉터
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: timecheck
  labels:
    kiamol: ch07
spec:
  selector:
    matchLabels:
      app: timecheck
  template:
    metadata:
      labels:
        app: timecheck
        version: v4
    spec:
      initContainers:
        - name: init-config
          image: kiamol/ch03-sleep
          command: ['sh', '-c', 'cp /config-in/appsettings.json /config-out/appsettings.json']          
          volumeMounts:
            - name: config-map
              mountPath: /config-in
            - name: config-dir
              mountPath: /config-out
      containers:                     # 애플리케이션 컨테이너, 로깅 컨테이너는 그대로이다.
        - name: timecheck
          image: kiamol/ch07-timecheck
          volumeMounts:
            - name: config-dir
              mountPath: /config
              readOnly: true
            - name: logs-dir
              mountPath: /logs
        - name: logger
          image: kiamol/ch03-sleep
          command: ['sh', '-c', 'tail -f /logs-ro/timecheck.log'] 
          volumeMounts:
            - name: logs-dir
              mountPath: /logs-ro
              readOnly: true
        - name: healthz                 # 추가되는 사이드카 컨테이너는 헬스체크 API를 제공한다.
          image: kiamol/ch03-sleep      # 이 응답은 하드코딩된 응답이다.
          command: ['sh', '-c', "while true; do echo -e 'HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 17\n\n{\"status\": \"OK\"}' | nc -l -p 8080; done"]
          ports:                        
            - containerPort: 8080       # 파드의 8080번 포트를 사용한다.
              name: http
        - name: metrics                 # 또 다른 사이드카 컨테이너, 성능 지표 API를 제공한다.
          image: kiamol/ch03-sleep      # 이 응답역시 하드코딩된 응답이다.
          command: ['sh', '-c', "while true; do echo -e 'HTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 104\n\n# HELP timechecks_total The total number timechecks.\n# TYPE timechecks_total counter\ntimechecks_total 6' | nc -l -p 8081; done"]
          ports:                       
            - containerPort: 8081       # 파드의 8081번 포트를 사용한다.
              name: http
      volumes:
        - name: config-map
          configMap:
            name: timecheck-config
        - name: config-dir
          emptyDir: {}
        - name: logs-dir
          emptyDir: {}

<!-- 실습 2 -->
# 파드 업데이트
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl apply -f .\timecheck\timecheck-good-citizen.yaml
service/timecheck created
deployment.apps/timecheck configured

# 컨테이너가 준비될 때까지 대기
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl wait --for=condition=Ready pod -l app=timecheck,version=v4
pod/timecheck-9b78898fd-rsmgz condition met

# 컨테이너의 상태 확인
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl get pod -l app=timecheck -o jsonpath='{.items[0].status.containerStatuses[*].name}'
healthz logger metrics timecheck

# sleep 컨테이너에서 timecheck 애플리케이션의 헬스 체크 API를 사용
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl exec deploy/sleep -c sleep -- wget -q -O - http://timecheck:8080
{"status": "OK"}

# sleep 컨테이너에서 성능 지표 api 를 사용
PS C:\ALL_WORKSPACE\0_GIT\kiamol\ch07> kubectl exec deploy/sleep -c sleep -- wget -q -O - http://timecheck:8081
# HELP timechecks_total The total number timechecks.
# TYPE timechecks_total counter
timechecks_total 6

# 어댑터 역할을 하는 사이드카 컨테이너는 오버헤드로 작용한다.
# 이미 실습예제에서 파드 업데이트에 걸리는 시간이 길어진 것을 보았을 것이다.
# 이뿐만 아니라 애플리케이션의 계산 성능 요구치도 증가하낟.
# 로그파일을 그대로 출력하거나 단순 HTTP 응답만 제공하는 사이드카 컨테이너라도 어느정도 계산 자원과 메모리 자원을 소모한다.
# 하지만 로그 수집이나 헬스체크 같은 기능이 없는 애플리케이션을 쿠버네티스로 이주하면서 관리의 일관성을 유지하고 싶다면 이것도 괜찬다.

# 애플리케이션의 네트워크 통신을 좀 더 세세하게 제어하고 싶다면 이 역시 사이드카 컨테ㅣ너로 가능하다.
# 애플리케이션 컨테이너에서 외부를 향하는 트래픽을 관리하는 프록시 컨테이너를 두면 된다.