<!-- 쿠버네티스 개발 워크플로 -->
# 여러 개발 조직에서 쿠버네티스에서 돌아가는 '서비스로서의 플랫폼'을 사용 중이다.
# 모든 테스트 환경과 CI/CD 서비스를 호스팅하는 클러스터를 운영하며 컨테이너 실행과 관련된 모든 일을 이 클러스터에 맡기는 것이다.
# 개발자 워크플로에서 모든 도커 아티팩트가 배제되므로 개발자는 애플리케이션 컴포넌트를 직접 다루며 Node.js 등 애플리케이션 실행에 필요한 모든 요소를 로컬 컴퓨터에서 실행한다.
# 그런 만큼 로컬에서 컨테이너를 이용할 일은 당연히 없다.

# 이 방식을 선택했다면 컨테이너는 외부 주기에서만 이용된다. 개발자가 변경 사항을 형상 관리 도구에 커밋하면 빌드가 일어나고, 이 빌드에서 컨테이너 이미지가 만들어져 레지스트리에 푸시된 후 새로운 버전이 애플리케이션이 클러스터 속 테스트 환경에 배치된다.
# 개발 업무에 컨테이너를 끌어들이는 데에서 오는 불편 없이도 컨테이너 플랫폼의 이점을 그대로 누릴 수 있다는 것이 장점이다.

# 이 방법의 장점은 개발 워크플로를 바꾸거나 개발 팀 모두가 도커나 컴포즈를 배우지 않고도 쿠버네티스로 이주할 수 있다는 점이다.
# 각 개발 팀이 소규모 컴포넌트를 나누어 담당하고 컴포넌트를 합쳐 전체 시스템을 구성하는 별도의 팀을 따로 두는 형태의 조직에 적합하다.
# 전체 시스템을 구성하는 팀만 컨테이너를 다룰 수 있으면 되기 때문이다.
# 클러스터에서 쓰는 컨테이너 런타임이 도커 엔진이 아닐 때 우용한 도커를 완전히 워크플로에서 배제할 수도 있다.
# 결국 전체적으로는 복잡도가 상승하지만 프로젝트가 아닌 전달 파이프라인으로 그 범위를 국한시킬 수 있다.

<!-- 실습 : 깃 서버 -->
# 곡스(Gogs)는 단순함에도 기능이 강력한 깃 서버로, 도커 허브에서 이미지를 내려받아 사용할 수 있다.
# 곡스는 사내용 비공개 깃 서버나 온라인 서버의 고장에 대비한 백업용 깃 서버로 사용하기 적합하다.

# 깃 서버를 배치
kubectl apply -f infrastructure/gogs.yaml

# 서버가 준비될 때까지 대기
kubectl wait --for=condition=ContainersReady pod -l app=gogs

# 예제 코드 리포지터리에 로컬 깃 서버를 추가
# 대상 URL을 서비스로부터 확인
git remote add gogs $(kubectl get svc gogs -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:3000/kiamol/kiamol.git')

# 서버에 코드를 푸시
# 사용자명 kiamol, 패스워드 kiamol을 사용
git push gogs

# 서버 URL을 확인
kubectl get svc gogs -o jsonpath='http://{.status.loadBalancer.ingress[0].*}:3000'

# 서버에 접근한 다음 kiamol 사용자명 및 패스워드로 로그인(kiamol/kiamol)

# 이제 우리가 마음대로 다른 컴포넌트를 연결할 수 있는 로컬 형상 관리 서버가 생겼다.
# 다음은 컨테이너 이미지를 빌드할 시스템을 만들차례다.
# 이 시스템이 아무 클러스터에서나 동작할 수 있으려면 다른 컨테이너 런타임도 사용할 수 있어야한다.
# 몇가지 선택지가 있지만 그중에서도 가장 좋은것이 도커에서 만든 오픈 소스 도구인 빌드킷(BuildKit)이다.
# 빌드킷은 도커 엔진의 이미지 빌드 기능을 대체하려고 시작된 프로젝트로, 다른 컴포넌트를 연결할 수 있는 기능을 갖추고 있다.
# 빌드킷을 사용하면 Dockerfile 스크립트가 없어도 이미지를 빌드할 수 있다.
# 빌드킷을 서버 형태로 실행하면 이미지 빌드 툴체인을 구성하는 다른 컴포넌트가 이미지를 빌드할 수 있다.

<!-- 실습 2 -->
# 클러스터에 빌드킷을 서버형태로 실행하라. 그릭 빌드킷에 도커 없이 이미지를 빌드하는데 필요한 모든 도구가 갖추어 있는지 확인하라.

# 빌드킷을 배치
kubectl apply -f infrastructure/buildkitd.yaml

# 빌드킷이 준비될 때까지 대기
kubectl wait --for=condition=ContainersReady pod -l app=buildkitd

# 깃과 빌드킷이 사용 가능한 상태인지 확인
kubectl exec deploy/buildkitd -- sh -c 'git version && buildctl --version'

# 도커가 설치되어 있지 않은 것을 확인 -- 오류 발생
kubectl exec deploy/buildkitd -- sh -c 'docker version'

# 전체 PaaS 파이프 라인을 완성하려면 몇가지 도구가 더 필요하지만, 빌드 과정 동작만 확인하는 준비는 된 상태다.
# 우리가 추구하는 목표는 도커를 배제한 파이프라인을 만드는 것이므로 앞서 사용했던 Dockerfile 스크립트는 무시하고 소스 코드에서 곧바로 컨테이너 이미지를 빌드해 보겠다.
# 현재는 CNCF로 이관되었지만 헤로쿠의 PaaS 서비스에서 처음 시도되었던 빌드팩이라는 기술이 있다.

# 빌드팩은 도커의 멀티스테이지 빌드와 동일한방식을 사용한다.
# 커넽이너에서 빌드 도구를 사용하고, 애플리케이션 런타임이 설치된 다른 컨테이너에서 컴파일된 애플리케이션을 패키징하는 과정을 거친다.

# 팩(Pack)이라는 도구를 사용하면 이런 과정이 가능하다.
# 팩은 소스 코드의 구현 언어가 무엇이든 빌드팩에서 처리될 수 있게 한 후 애플리케이션을 이미지로 패키징한다. 이 과정에서 Dockerfile 스크립트는 필요없다.
# 현재 팩을 사용하려면 도커가 필요하기때문에 도커를 배제한 파이프라인을 만들 수 있도록 팩을 대신해서 빌드팩을 빌드킷에 통합하여 사용한다.

<!-- 실습 3 -->
# 수동으로 실해오디는 빌드 절차로 시작하여 자동화해볼 것이다. 빌드킷 파드에 접속하여 로컬 깃 서버에서 이 책에 필요한 예제 코드를 내려받아라. 그리고 Dockerfile 스크립트 대신 빌드팩을 사용하여 소스코드를 빌드하라

# 빌드킷 파드에 접속
kubectl exec -it deploy/buildkitd -- sh

# 곡스 서버에서 소스 코드를 복제
cd ~
git clone https://github.com/sixeyed/kiamol.git
Cloning into 'kiamol'...
remote: Enumerating objects: 3571, done.
remote: Counting objects: 100% (533/533), done.
remote: Compressing objects: 100% (216/216), done.
remote: Total 3571 (delta 348), reused 317 (delta 317), pack-reused 3038
Receiving objects: 100% (3571/3571), 10.54 MiB | 10.89 MiB/s, done.
Resolving deltas: 100% (1784/1784), done.

# 애플리케이션 디렉터리로 이동
cd kiamol/ch11/bulletin-board/

# 빌드킷으로 애플리케이션을 빌드
# 옵션의 의미는 Dockerfile 스크립트 대신 빌드팩을 사용하고
# 빌드 결과로 컨테이너 이미지를 내놓으라는 뜻이다
buildctl build --frontend=gateway.v0 --opt source=kiamol/buildkit-buildpacks --local context=src --output type=image,name=kiamol/ch11-bulletin-board:buildkit

# 빌드가 끝나면 파드에서 접속을 종료한다
exit

# 이번 실습 예제는 실행에 시간이 조금 걸린다. 하지만 빌드킷에서 출력되는 내용을 눈여겨보면 어떤 과정을 거치는지 알수있다.
# 먼저, 빌드팩 통합에 필요한 컴포넌트를 내려받는다
# 그다음 그 컴포넌트를 이용해서 소스코드가 Node.js 애플리케이션임을 확인한다. 애플리케이션을 압축 파일 형태로 패키징하고, Node.js 런타임이 설치된 컨테이너 이미지에 압축 파일을 포함시킨다.

# 빌드킷 파드에는 컨테이너 런타임이 없기때문에 이 이미지로 바로 컨테이너를 실행해 볼수 없다.
# 그 대신 빌드킷으로 빌드된 이미지를 레지스트리에 푸시한다. 이 과정으로 워크플로가 완성됬다. 이것으로 Dockerfile 스크립트나 도커 없이도 애플리케이션을 비드하고 이미지로 패키징할 수 있다는 것은 확인했다. 과정은 좀 복잡하기는 했지만 말이다.

# 이 두가지 도구를 연결하는 (빌드팩 , 빌드킷) 컴포넌트는 빌드킷 프로젝트 메인테이너인 토니스 티기(Tonis tigi)가 만들었다
# 빌드팩과 빌드킷을 연결할 수 있다는 점을 보여 워크플로의 가능성을 보여주는 목적은 달성했다. 
# 다만 아직 실무에서 사용할 수 있는 완성도는 아니다.

# 이를 대체할 수단도 있다.
# 깃랩(GitLab)은 빌드팩과 쿠버네티스 환경을 위한 네이티브 빌드 서버인 젠킨스X(Jenkins X)로 구서오딘 빌드 파이프라인을 깃 서버와 통합한 제품이다.
# 이들 도구는 자체만으로도 꽤 복잡도가 높은데, 개발 워크플로에서 도커를 배제하려면 이들을 다시 빌드 절차로 엮어 내는 복잡도를 추가로 감내해야한다.